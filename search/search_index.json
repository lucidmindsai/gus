{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gus Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis. Installation Install GUS from PyPi: $ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple gus == 0 .1.8 You can use, Poetry as well: $ poetry add gus Development Create a virtualenv by using pyenv, install it first: $ brew install readline xz $ brew install pyenv pyenv-virtualenv Add those to your ~/.bashrc or ~/.zshrc (or any profiler you use) eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" Install a specific python version: $ pyenv install 3 .9.12 -- Pick your Python version ( 3 .8 is available too ) Create a virtualenv: $ pyenv virtualenv 3 .9.12 gus To enable virtualenv: $ pyenv shell gus Now run poetry to setup GUS: $ poetry build Stick to PEP8 rules for code development. To do the checks, install flake8 to your local machine: $ pip3 install flake8 Once you're done with developing on your branch, before pushing your changes, please run: $ flake8 <file_you_changed_or_added> Please fix the errors and warnings if they appear. Testing The code is tested by through pytest , which is included in the requirements.txt . You can manually install it with the command: $ pip3 install pytest And run the tests: $ pytest All tests are in the tests/ folder","title":"Home"},{"location":"#gus","text":"Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis.","title":"gus"},{"location":"#installation","text":"Install GUS from PyPi: $ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple gus == 0 .1.8 You can use, Poetry as well: $ poetry add gus","title":"Installation"},{"location":"#development","text":"Create a virtualenv by using pyenv, install it first: $ brew install readline xz $ brew install pyenv pyenv-virtualenv Add those to your ~/.bashrc or ~/.zshrc (or any profiler you use) eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" Install a specific python version: $ pyenv install 3 .9.12 -- Pick your Python version ( 3 .8 is available too ) Create a virtualenv: $ pyenv virtualenv 3 .9.12 gus To enable virtualenv: $ pyenv shell gus Now run poetry to setup GUS: $ poetry build Stick to PEP8 rules for code development. To do the checks, install flake8 to your local machine: $ pip3 install flake8 Once you're done with developing on your branch, before pushing your changes, please run: $ flake8 <file_you_changed_or_added> Please fix the errors and warnings if they appear.","title":"Development"},{"location":"#testing","text":"The code is tested by through pytest , which is included in the requirements.txt . You can manually install it with the command: $ pip3 install pytest And run the tests: $ pytest All tests are in the tests/ folder","title":"Testing"},{"location":"README-pypi/","text":"gus Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis. install GUS from Test-PyPi import sys ! { sys . executable } - m pip install -- index - url https : // test . pypi . org / simple / -- extra - index - url https : // pypi . org / simple gus == 0.1.7","title":"gus"},{"location":"README-pypi/#gus","text":"Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis.","title":"gus"},{"location":"README-pypi/#install-gus-from-test-pypi","text":"import sys ! { sys . executable } - m pip install -- index - url https : // test . pypi . org / simple / -- extra - index - url https : // pypi . org / simple gus == 0.1.7","title":"install GUS from Test-PyPi"},{"location":"reference/src/","text":"Module src None None Sub-modules src.gus src.impacts","title":"Index"},{"location":"reference/src/#module-src","text":"None None","title":"Module src"},{"location":"reference/src/#sub-modules","text":"src.gus src.impacts","title":"Sub-modules"},{"location":"reference/src/gus/","text":"Module src.gus None None Sub-modules src.gus.agents src.gus.allometrics src.gus.models src.gus.utilities src.gus.weather","title":"Index"},{"location":"reference/src/gus/#module-srcgus","text":"None None","title":"Module src.gus"},{"location":"reference/src/gus/#sub-modules","text":"src.gus.agents src.gus.allometrics src.gus.models src.gus.utilities src.gus.weather","title":"Sub-modules"},{"location":"reference/src/gus/agents/","text":"Module src.gus.agents None None View Source # -*- coding: utf-8 -*- # Basic Python packages import numpy as np # Mesa Packages from mesa import Agent class Tree ( Agent ): \"\"\"A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\"\" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ): \"\"\"The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \"deciduous\" or \"coniferous\" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\"\" # Initializing parent Class. super () . __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ): \"\"\"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\"\" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ): \"\"\"The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\"\" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ): \"\"\"Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ): \"\"\"Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ): \"\"\"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\"\" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ): \"\"\"A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\"\" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ): \"\"\"The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\"\" def register_death (): self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ): register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ): \"\"\"Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\"\" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ): \"\"\"Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\"\" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \"\"\"The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\"\" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ): \"\"\"The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\"\" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ): \"\"\"The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\"\" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ): \"\"\"The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\"\" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ): self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \"\"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\"\" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id Classes Tree class Tree ( unique_id , model , dbh , species , height = None , kind = 'deciduous' , fixed_sun_exposure = False , condition = None , dieback = None ) View Source class Tree ( Agent ) : \" \"\" A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\" \" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ) : \" \"\" The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \" deciduous \" or \" coniferous \" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\" \" # Initializing parent Class. super (). __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ) : \" \"\" State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ) : \" \"\" Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\" \" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ) : \" \"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ) : \" \"\" Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\" \" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ) : \" \"\" Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\" \" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ) : \" \"\" The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\" \" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ) : \" \"\" The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\" \" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id Ancestors (in MRO) mesa.agent.Agent Class variables carbon_coeff carbon_storage_cap condition_multiplier crown_to_trunk_ratio decomposition_coeff root_to_shoot_ratio sequestration_at_maturity sun_exposure_rates Instance variables random Methods advance def advance ( self ) -> None View Source def advance ( self ) -> None : pass check_dieback def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj: float ): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj: float ): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj: float ): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. View Source def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback compute_biomass def compute_biomass ( self , ignore_height = True ) -> float The biomass calculation for the tree, in KG. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. None Ex None 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): Biomass in Kg. Todo: Update the generic biomass. View Source def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass compute_contagion_risk def compute_contagion_risk ( self ) A very simplified version of contagion. Args: None Returns: (:obj: float ): contagion risk a value within the inclusive range [0,0.9] View Source def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk compute_decomposition def compute_decomposition ( self ) The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. View Source def compute_decomposition ( self ) : \"\"\" The amount of carbon release in KG due to partial diebacks. Args : None Returns : None Todo : This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised . \"\"\" # self . release = self . decomposition_rate * self . dieback * self . carbon_storage self . _reset_release_track () if self . condition == ' dead ' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () compute_light_exposure def compute_light_exposure ( self ) The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. View Source def compute_light_exposure ( self ) : \"\"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE . Args : None Returns : None Note : Current version checks out other trees within the same grid . It checks height and width of each neighboring tree . Canopy overlap ratio is used as proxy to determine available CLE . The model assumes that a taller neighbourung tree reduces sun light exposure . Todo : * The assumption needs to be revisited and validated . * The model needs to be revised in case the same location is shared by other species . \"\"\" if self . fixed_sun_exposure : return # cellmates = self . model . grid . get_cell_list_contents ( [ self . pos ] ) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0 . 5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape . overlap = max ( 0 , 0 . 5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0 . 25 multiplier is to account one of the four sides of the grid cell . overlap_ratio = 0 . 25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0 . 75 # arbitrary to be fixed with empirical data . self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) compute_sequestration def compute_sequestration ( self ) The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj: float ): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors View Source def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration estimate_tree_height def estimate_tree_height ( self ) Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) View Source def estimate_tree_height ( self ) : \"\"\" Computes the height of tree based on the species and current dbh. Args : None Returns : None Todo : In case of absence of a height function a generic function is used . Current generic function is based on family of height functions yet still arbitrary . It needs to be updated by the higher level phenotypes ( needle , leaf , etc . ) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height fleming_height def fleming_height ( self ) Updates the tree height based on the model by Fleming (1988) Args: None Returns: None View Source def fleming_height(self): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self.tree_height += Tree.condition_multiplier[self.condition] * 0.15 grow def grow ( self , frost_free_days ) The method updates DBH of the tree. Currently it is an annual growth in cm. Parameters: Name Type Description Default frost_free_days None (:obj: int ): the number of observed frost free days None Returns: Type Description None None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201c maximum \u201d height , growth rate decreases . Thus , the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species . The estimated tree height at maturity is derived from the literature . When a tree \u2019 s height is more than 80 percent of its average height at maturity , the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2 . 22 percent of full growth at 125 percent of height at maturity . Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods | View Source def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () replace def replace ( self ) -> int In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj: int ): new agent id. View Source def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id step def step ( self ) State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None View Source def step ( self ) : \"\"\" State transitions of a given Tree agent. Args : None Returns : None Note : None Todo : None \"\"\" # Once the replaced tree agents are removed from the model , this line will be idle and s # should be removed too . if self . condition == ' replaced ' : return # The tree is dead and its carbon release schedule is accounted . if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == ' dead ' : self . compute_decomposition () return # check frost free days for the past year . frost_free_days = self . model . WeatherAPI . check_frost_free_days () # print ( ' Tree: {} checks ffdays = {} ... ' . format ( self . unique_id , frost_free_days )) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree # print ( ' Tree: {} checks dieback ... ' . format ( self . unique_id )) self . check_dieback () # compute the growth # print ( ' Tree: {} grows ... ' . format ( self . unique_id )) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () # print ( ' Tree: {} biomass ... ' . format ( self . unique_id )) # compute the amount of new carbon sequestration self . compute_sequestration () # print ( ' Tree: {} sequestration ... ' . format ( self . unique_id )) # compute the amount of carbon release due to decomposition # print ( ' Tree: {} decomposition ... ' . format ( self . unique_id )) self . compute_decomposition () update_crown_height def update_crown_height ( self ) Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height update_crown_width def update_crown_width ( self ) Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width update_tree_height def update_tree_height ( self , generic = False ) Computes the height of tree based on the species and current dbh. Args: None Returns: None View Source def update_tree_height ( self , generic = False ) : \"\"\" Computes the height of tree based on the species and current dbh. Args : None Returns : None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh )","title":"Agents"},{"location":"reference/src/gus/agents/#module-srcgusagents","text":"None None View Source # -*- coding: utf-8 -*- # Basic Python packages import numpy as np # Mesa Packages from mesa import Agent class Tree ( Agent ): \"\"\"A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\"\" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ): \"\"\"The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \"deciduous\" or \"coniferous\" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\"\" # Initializing parent Class. super () . __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ): \"\"\"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\"\" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ): \"\"\"The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\"\" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ): \"\"\"Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ): \"\"\"Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ): \"\"\"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\"\" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ): \"\"\"A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\"\" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ): \"\"\"The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\"\" def register_death (): self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ): register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ): \"\"\"Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\"\" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ): \"\"\"Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\"\" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \"\"\"The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\"\" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ): \"\"\"The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\"\" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ): \"\"\"The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\"\" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ): \"\"\"The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\"\" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ): self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \"\"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\"\" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"Module src.gus.agents"},{"location":"reference/src/gus/agents/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/agents/#tree","text":"class Tree ( unique_id , model , dbh , species , height = None , kind = 'deciduous' , fixed_sun_exposure = False , condition = None , dieback = None ) View Source class Tree ( Agent ) : \" \"\" A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\" \" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ) : \" \"\" The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \" deciduous \" or \" coniferous \" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\" \" # Initializing parent Class. super (). __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ) : \" \"\" State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ) : \" \"\" Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\" \" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ) : \" \"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ) : \" \"\" Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\" \" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ) : \" \"\" Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\" \" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ) : \" \"\" The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\" \" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ) : \" \"\" The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\" \" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"Tree"},{"location":"reference/src/gus/agents/#ancestors-in-mro","text":"mesa.agent.Agent","title":"Ancestors (in MRO)"},{"location":"reference/src/gus/agents/#class-variables","text":"carbon_coeff carbon_storage_cap condition_multiplier crown_to_trunk_ratio decomposition_coeff root_to_shoot_ratio sequestration_at_maturity sun_exposure_rates","title":"Class variables"},{"location":"reference/src/gus/agents/#instance-variables","text":"random","title":"Instance variables"},{"location":"reference/src/gus/agents/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/agents/#advance","text":"def advance ( self ) -> None View Source def advance ( self ) -> None : pass","title":"advance"},{"location":"reference/src/gus/agents/#check_dieback","text":"def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj: float ): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj: float ): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj: float ): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. View Source def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback","title":"check_dieback"},{"location":"reference/src/gus/agents/#compute_biomass","text":"def compute_biomass ( self , ignore_height = True ) -> float The biomass calculation for the tree, in KG. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. None Ex None 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): Biomass in Kg. Todo: Update the generic biomass. View Source def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass","title":"compute_biomass"},{"location":"reference/src/gus/agents/#compute_contagion_risk","text":"def compute_contagion_risk ( self ) A very simplified version of contagion. Args: None Returns: (:obj: float ): contagion risk a value within the inclusive range [0,0.9] View Source def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk","title":"compute_contagion_risk"},{"location":"reference/src/gus/agents/#compute_decomposition","text":"def compute_decomposition ( self ) The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. View Source def compute_decomposition ( self ) : \"\"\" The amount of carbon release in KG due to partial diebacks. Args : None Returns : None Todo : This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised . \"\"\" # self . release = self . decomposition_rate * self . dieback * self . carbon_storage self . _reset_release_track () if self . condition == ' dead ' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive ()","title":"compute_decomposition"},{"location":"reference/src/gus/agents/#compute_light_exposure","text":"def compute_light_exposure ( self ) The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. View Source def compute_light_exposure ( self ) : \"\"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE . Args : None Returns : None Note : Current version checks out other trees within the same grid . It checks height and width of each neighboring tree . Canopy overlap ratio is used as proxy to determine available CLE . The model assumes that a taller neighbourung tree reduces sun light exposure . Todo : * The assumption needs to be revisited and validated . * The model needs to be revised in case the same location is shared by other species . \"\"\" if self . fixed_sun_exposure : return # cellmates = self . model . grid . get_cell_list_contents ( [ self . pos ] ) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0 . 5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape . overlap = max ( 0 , 0 . 5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0 . 25 multiplier is to account one of the four sides of the grid cell . overlap_ratio = 0 . 25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0 . 75 # arbitrary to be fixed with empirical data . self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap )","title":"compute_light_exposure"},{"location":"reference/src/gus/agents/#compute_sequestration","text":"def compute_sequestration ( self ) The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj: float ): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors View Source def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration","title":"compute_sequestration"},{"location":"reference/src/gus/agents/#estimate_tree_height","text":"def estimate_tree_height ( self ) Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) View Source def estimate_tree_height ( self ) : \"\"\" Computes the height of tree based on the species and current dbh. Args : None Returns : None Todo : In case of absence of a height function a generic function is used . Current generic function is based on family of height functions yet still arbitrary . It needs to be updated by the higher level phenotypes ( needle , leaf , etc . ) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height","title":"estimate_tree_height"},{"location":"reference/src/gus/agents/#fleming_height","text":"def fleming_height ( self ) Updates the tree height based on the model by Fleming (1988) Args: None Returns: None View Source def fleming_height(self): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self.tree_height += Tree.condition_multiplier[self.condition] * 0.15","title":"fleming_height"},{"location":"reference/src/gus/agents/#grow","text":"def grow ( self , frost_free_days ) The method updates DBH of the tree. Currently it is an annual growth in cm. Parameters: Name Type Description Default frost_free_days None (:obj: int ): the number of observed frost free days None Returns: Type Description None None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201c maximum \u201d height , growth rate decreases . Thus , the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species . The estimated tree height at maturity is derived from the literature . When a tree \u2019 s height is more than 80 percent of its average height at maturity , the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2 . 22 percent of full growth at 125 percent of height at maturity . Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods | View Source def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height ()","title":"grow"},{"location":"reference/src/gus/agents/#replace","text":"def replace ( self ) -> int In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj: int ): new agent id. View Source def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"replace"},{"location":"reference/src/gus/agents/#step","text":"def step ( self ) State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None View Source def step ( self ) : \"\"\" State transitions of a given Tree agent. Args : None Returns : None Note : None Todo : None \"\"\" # Once the replaced tree agents are removed from the model , this line will be idle and s # should be removed too . if self . condition == ' replaced ' : return # The tree is dead and its carbon release schedule is accounted . if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == ' dead ' : self . compute_decomposition () return # check frost free days for the past year . frost_free_days = self . model . WeatherAPI . check_frost_free_days () # print ( ' Tree: {} checks ffdays = {} ... ' . format ( self . unique_id , frost_free_days )) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree # print ( ' Tree: {} checks dieback ... ' . format ( self . unique_id )) self . check_dieback () # compute the growth # print ( ' Tree: {} grows ... ' . format ( self . unique_id )) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () # print ( ' Tree: {} biomass ... ' . format ( self . unique_id )) # compute the amount of new carbon sequestration self . compute_sequestration () # print ( ' Tree: {} sequestration ... ' . format ( self . unique_id )) # compute the amount of carbon release due to decomposition # print ( ' Tree: {} decomposition ... ' . format ( self . unique_id )) self . compute_decomposition ()","title":"step"},{"location":"reference/src/gus/agents/#update_crown_height","text":"def update_crown_height ( self ) Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height","title":"update_crown_height"},{"location":"reference/src/gus/agents/#update_crown_width","text":"def update_crown_width ( self ) Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width","title":"update_crown_width"},{"location":"reference/src/gus/agents/#update_tree_height","text":"def update_tree_height ( self , generic = False ) Computes the height of tree based on the species and current dbh. Args: None Returns: None View Source def update_tree_height ( self , generic = False ) : \"\"\" Computes the height of tree based on the species and current dbh. Args : None Returns : None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh )","title":"update_tree_height"},{"location":"reference/src/gus/allometrics/","text":"Module src.gus.allometrics None None View Source # -*- coding: utf-8 -*- # Importing Python Libraries import numpy as np import json from fuzzywuzzy import process class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric Classes Species class Species ( species_db ) View Source class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @ staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric Class variables root_to_shoot_ratio Static methods filter_dbh_size def filter_dbh_size ( dbh , minv , maxv ) Utility function to assure the range of dbh that can be used by the growth functions View Source @staticmethod def filter_dbh_size ( dbh , minv , maxv ) : \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) fit_exponential def fit_exponential ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp fit_parametric def fit_parametric ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric fit_polynomial def fit_polynomial ( params ) Static method that sets the constant of a second degree polynomial function. View Source @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol Methods fuzzymatching def fuzzymatching ( self , species ) Fuzzy matching species name. Parameters: Name Type Description Default species None (:obj: string ): name of the species None Returns: Type Description ( obj: string ): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. | View Source def fuzzymatching ( self , species ) : \" \"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\" \" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest get_diameter_growth def get_diameter_growth ( self , species ) Retrieve annual avg diameter growth rate for the site for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): the standard growth per year in cm. View Source def get_diameter_growth ( self , species ) : \" \"\" Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 get_eqn def get_eqn ( self , species_name , allometry_type ) The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: f(string)->float ): the growth function View Source def get_eqn ( self , species_name , allometry_type ) : \" \"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\" \" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) get_eqn_biomass def get_eqn_biomass ( self , species_name ) The method retrieves constants of a bimomass function for the given species and returns the species specific function. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None Returns: Type Description ( obj: f(string)->float ): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. View Source def get_eqn_biomass ( self , species_name ) : \" \"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\" \" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) get_form_and_constants def get_form_and_constants ( self , species_name , allometry_type ) The method retrieves parameters and type of a growth function for the given species. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: (string, dict ) View Source def get_form_and_constants ( self , species_name , allometry_type ) : \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) get_height_at_maturity def get_height_at_maturity ( self , species ) Observed avg total height of the tree for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: int ): Avg height in meters. View Source def get_height_at_maturity ( self , species ) : \" \"\" Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 list_species def list_species ( self ) List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj: list of String ): List of species names. View Source def list_species ( self ) : \" \"\" List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\" \" return list ( self . parameters . keys ())","title":"Allometrics"},{"location":"reference/src/gus/allometrics/#module-srcgusallometrics","text":"None None View Source # -*- coding: utf-8 -*- # Importing Python Libraries import numpy as np import json from fuzzywuzzy import process class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"Module src.gus.allometrics"},{"location":"reference/src/gus/allometrics/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/allometrics/#species","text":"class Species ( species_db ) View Source class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @ staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"Species"},{"location":"reference/src/gus/allometrics/#class-variables","text":"root_to_shoot_ratio","title":"Class variables"},{"location":"reference/src/gus/allometrics/#static-methods","text":"","title":"Static methods"},{"location":"reference/src/gus/allometrics/#filter_dbh_size","text":"def filter_dbh_size ( dbh , minv , maxv ) Utility function to assure the range of dbh that can be used by the growth functions View Source @staticmethod def filter_dbh_size ( dbh , minv , maxv ) : \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh )","title":"filter_dbh_size"},{"location":"reference/src/gus/allometrics/#fit_exponential","text":"def fit_exponential ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp","title":"fit_exponential"},{"location":"reference/src/gus/allometrics/#fit_parametric","text":"def fit_parametric ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"fit_parametric"},{"location":"reference/src/gus/allometrics/#fit_polynomial","text":"def fit_polynomial ( params ) Static method that sets the constant of a second degree polynomial function. View Source @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol","title":"fit_polynomial"},{"location":"reference/src/gus/allometrics/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/allometrics/#fuzzymatching","text":"def fuzzymatching ( self , species ) Fuzzy matching species name. Parameters: Name Type Description Default species None (:obj: string ): name of the species None Returns: Type Description ( obj: string ): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. | View Source def fuzzymatching ( self , species ) : \" \"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\" \" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest","title":"fuzzymatching"},{"location":"reference/src/gus/allometrics/#get_diameter_growth","text":"def get_diameter_growth ( self , species ) Retrieve annual avg diameter growth rate for the site for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): the standard growth per year in cm. View Source def get_diameter_growth ( self , species ) : \" \"\" Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382","title":"get_diameter_growth"},{"location":"reference/src/gus/allometrics/#get_eqn","text":"def get_eqn ( self , species_name , allometry_type ) The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: f(string)->float ): the growth function View Source def get_eqn ( self , species_name , allometry_type ) : \" \"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\" \" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type ))","title":"get_eqn"},{"location":"reference/src/gus/allometrics/#get_eqn_biomass","text":"def get_eqn_biomass ( self , species_name ) The method retrieves constants of a bimomass function for the given species and returns the species specific function. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None Returns: Type Description ( obj: f(string)->float ): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. View Source def get_eqn_biomass ( self , species_name ) : \" \"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\" \" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio )","title":"get_eqn_biomass"},{"location":"reference/src/gus/allometrics/#get_form_and_constants","text":"def get_form_and_constants ( self , species_name , allometry_type ) The method retrieves parameters and type of a growth function for the given species. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: (string, dict ) View Source def get_form_and_constants ( self , species_name , allometry_type ) : \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params )","title":"get_form_and_constants"},{"location":"reference/src/gus/allometrics/#get_height_at_maturity","text":"def get_height_at_maturity ( self , species ) Observed avg total height of the tree for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: int ): Avg height in meters. View Source def get_height_at_maturity ( self , species ) : \" \"\" Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25","title":"get_height_at_maturity"},{"location":"reference/src/gus/allometrics/#list_species","text":"def list_species ( self ) List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj: list of String ): List of species names. View Source def list_species ( self ) : \" \"\" List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\" \" return list ( self . parameters . keys ())","title":"list_species"},{"location":"reference/src/gus/models/","text":"Module src.gus.models None None View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # Importing Python Libraries import site import numpy as np from functools import reduce import json import logging # Importing necessary Mesa packages from mesa import Model from mesa.time import RandomActivation from mesa.space import MultiGrid from mesa.datacollection import DataCollector # Importing needed SAF objects from .agents import Tree from .allometrics import Species from .weather import WeatherSim class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year: {} \" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a. {} ' . format ( var )) for a in model . schedule . agents ], init ) @staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a. {} ' . format ( memory )) for a in model . schedule . agents ]))) @staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) Classes Urban class Urban ( population , species_composition , site_config , scenario , batch = False ) View Source class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year:{}\" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) @ staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a.{}' . format ( memory )) for a in model . schedule . agents ]))) @ staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @ staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @ staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @ staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) Ancestors (in MRO) mesa.model.Model Class variables dt_resolution site_types Static methods agg_std_sequestration def agg_std_sequestration ( model ) The function estimates the standard deviation for yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. View Source @staticmethod def agg_std_sequestration ( model ) : \" \"\" The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) aggregate def aggregate ( model , var , func =< function Urban .< lambda > at 0x130103c10 > , init = 0 ) A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. View Source @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) aggregate_sequestration def aggregate_sequestration ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def aggregate_sequestration ( model ) : \" \"\" The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) compute_carbon_release_rate def compute_carbon_release_rate ( year , state = 'fast' ) Determines a carbon release rate. Parameters: Name Type Description Default year None (:obj: int ) or (:obj: float ): time passed since the biomass is dead. None state None (:obj: str ): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) None Returns: Type Description ( obj: float ): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts . The shape of function assures a unit integral as time goes to infinity . When k = 2 , in the first 3 years around 60 % is released , which corresponds to empirical findings for mulched biomass above ground . When k = 5 , in the first 3 years around 40 % is released , which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots . check : import scipy.integrate as integrate integrate . quad ( f , 0 , 20 ) > 0.96 for k in ( 2 : 5 ) . | View Source @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ) : \" \"\" Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\" \" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) compute_current_carbon_release def compute_current_carbon_release ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def compute_current_carbon_release ( model ) : \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np . array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ] , 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ] , 1 ) # aggregate required type of release ( mulched , etc ) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ) : carbon_release = 0 for i in range ( len ( model . release_bins [ type ] )) : mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate count def count ( model , memory , predicate ) A higher order function for counting agents that satisfy a specific attribute. View Source @staticmethod def count ( model , memory , predicate ) : \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval( 'a.{}'.format(memory)) for a in model.schedule.agents ] ))) Methods get_weather_projection def get_weather_projection ( self ) The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. View Source def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) next_id def next_id ( self ) -> int Return the next unique ID for agents, increment current_id View Source def next_id ( self ) -> int : \"\"\"Return the next unique ID for agents, increment current_id\"\"\" self . current_id += 1 return self . current_id reset_randomizer def reset_randomizer ( self , seed : Union [ int , NoneType ] = None ) -> None Reset the model random number generator. Parameters: Name Type Description Default seed None A new seed for the RNG; if None, reset using the current seed None View Source def reset_randomizer ( self , seed : Optional [ int ] = None ) -> None : \"\"\"Reset the model random number generator. Args: seed: A new seed for the RNG; if None, reset using the current seed \"\"\" if seed is None : seed = self . _seed self . random . seed ( seed ) self . _seed = seed run_model def run_model ( self ) -> None Run the model until the end condition is reached. Overload as needed. View Source def run_model ( self ) -> None : \"\"\"Run the model until the end condition is reached. Overload as needed. \"\"\" while self . running : self . step () step def step ( self ) Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: View Source def step(self): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging.info(\"Year:{}\".format(self.schedule.time + 1)) self.get_weather_projection() logging.info(\"Agents are working ...\") self.schedule.step() logging.info(\"Yearly data is being collected ...\") self.datacollector.collect(self)","title":"Models"},{"location":"reference/src/gus/models/#module-srcgusmodels","text":"None None View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # Importing Python Libraries import site import numpy as np from functools import reduce import json import logging # Importing necessary Mesa packages from mesa import Model from mesa.time import RandomActivation from mesa.space import MultiGrid from mesa.datacollection import DataCollector # Importing needed SAF objects from .agents import Tree from .allometrics import Species from .weather import WeatherSim class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year: {} \" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a. {} ' . format ( var )) for a in model . schedule . agents ], init ) @staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a. {} ' . format ( memory )) for a in model . schedule . agents ]))) @staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"Module src.gus.models"},{"location":"reference/src/gus/models/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/models/#urban","text":"class Urban ( population , species_composition , site_config , scenario , batch = False ) View Source class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year:{}\" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) @ staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a.{}' . format ( memory )) for a in model . schedule . agents ]))) @ staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @ staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @ staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @ staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"Urban"},{"location":"reference/src/gus/models/#ancestors-in-mro","text":"mesa.model.Model","title":"Ancestors (in MRO)"},{"location":"reference/src/gus/models/#class-variables","text":"dt_resolution site_types","title":"Class variables"},{"location":"reference/src/gus/models/#static-methods","text":"","title":"Static methods"},{"location":"reference/src/gus/models/#agg_std_sequestration","text":"def agg_std_sequestration ( model ) The function estimates the standard deviation for yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. View Source @staticmethod def agg_std_sequestration ( model ) : \" \"\" The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured )","title":"agg_std_sequestration"},{"location":"reference/src/gus/models/#aggregate","text":"def aggregate ( model , var , func =< function Urban .< lambda > at 0x130103c10 > , init = 0 ) A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. View Source @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init )","title":"aggregate"},{"location":"reference/src/gus/models/#aggregate_sequestration","text":"def aggregate_sequestration ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def aggregate_sequestration ( model ) : \" \"\" The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured )","title":"aggregate_sequestration"},{"location":"reference/src/gus/models/#compute_carbon_release_rate","text":"def compute_carbon_release_rate ( year , state = 'fast' ) Determines a carbon release rate. Parameters: Name Type Description Default year None (:obj: int ) or (:obj: float ): time passed since the biomass is dead. None state None (:obj: str ): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) None Returns: Type Description ( obj: float ): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts . The shape of function assures a unit integral as time goes to infinity . When k = 2 , in the first 3 years around 60 % is released , which corresponds to empirical findings for mulched biomass above ground . When k = 5 , in the first 3 years around 40 % is released , which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots . check : import scipy.integrate as integrate integrate . quad ( f , 0 , 20 ) > 0.96 for k in ( 2 : 5 ) . | View Source @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ) : \" \"\" Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\" \" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"compute_carbon_release_rate"},{"location":"reference/src/gus/models/#compute_current_carbon_release","text":"def compute_current_carbon_release ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def compute_current_carbon_release ( model ) : \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np . array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ] , 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ] , 1 ) # aggregate required type of release ( mulched , etc ) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ) : carbon_release = 0 for i in range ( len ( model . release_bins [ type ] )) : mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate","title":"compute_current_carbon_release"},{"location":"reference/src/gus/models/#count","text":"def count ( model , memory , predicate ) A higher order function for counting agents that satisfy a specific attribute. View Source @staticmethod def count ( model , memory , predicate ) : \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval( 'a.{}'.format(memory)) for a in model.schedule.agents ] )))","title":"count"},{"location":"reference/src/gus/models/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/models/#get_weather_projection","text":"def get_weather_projection ( self ) The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. View Source def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var )","title":"get_weather_projection"},{"location":"reference/src/gus/models/#next_id","text":"def next_id ( self ) -> int Return the next unique ID for agents, increment current_id View Source def next_id ( self ) -> int : \"\"\"Return the next unique ID for agents, increment current_id\"\"\" self . current_id += 1 return self . current_id","title":"next_id"},{"location":"reference/src/gus/models/#reset_randomizer","text":"def reset_randomizer ( self , seed : Union [ int , NoneType ] = None ) -> None Reset the model random number generator. Parameters: Name Type Description Default seed None A new seed for the RNG; if None, reset using the current seed None View Source def reset_randomizer ( self , seed : Optional [ int ] = None ) -> None : \"\"\"Reset the model random number generator. Args: seed: A new seed for the RNG; if None, reset using the current seed \"\"\" if seed is None : seed = self . _seed self . random . seed ( seed ) self . _seed = seed","title":"reset_randomizer"},{"location":"reference/src/gus/models/#run_model","text":"def run_model ( self ) -> None Run the model until the end condition is reached. Overload as needed. View Source def run_model ( self ) -> None : \"\"\"Run the model until the end condition is reached. Overload as needed. \"\"\" while self . running : self . step ()","title":"run_model"},{"location":"reference/src/gus/models/#step","text":"def step ( self ) Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: View Source def step(self): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging.info(\"Year:{}\".format(self.schedule.time + 1)) self.get_weather_projection() logging.info(\"Agents are working ...\") self.schedule.step() logging.info(\"Yearly data is being collected ...\") self.datacollector.collect(self)","title":"step"},{"location":"reference/src/gus/utilities/","text":"Module src.gus.utilities None None View Source # -*- coding: utf-8 -*- from functools import reduce import numpy as np def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a. {} ' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster Functions get_raster_data def get_raster_data ( dtwin , var = 'unique_id' , probe =< function < lambda > at 0x1301c01f0 > , predicate =< function < lambda > at 0x1301c0310 > , init = 0 , counts = False ) A general purpose function that collects celular data on the grid. Parameters: Name Type Description Default dtwin None (:obj: Urban ): an urban forest model. None var None (:obj: string ): a valid memory variable of a tree. None Returns: Type Description ( obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: View Source def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a.{}' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"Utilities"},{"location":"reference/src/gus/utilities/#module-srcgusutilities","text":"None None View Source # -*- coding: utf-8 -*- from functools import reduce import numpy as np def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a. {} ' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"Module src.gus.utilities"},{"location":"reference/src/gus/utilities/#functions","text":"","title":"Functions"},{"location":"reference/src/gus/utilities/#get_raster_data","text":"def get_raster_data ( dtwin , var = 'unique_id' , probe =< function < lambda > at 0x1301c01f0 > , predicate =< function < lambda > at 0x1301c0310 > , init = 0 , counts = False ) A general purpose function that collects celular data on the grid. Parameters: Name Type Description Default dtwin None (:obj: Urban ): an urban forest model. None var None (:obj: string ): a valid memory variable of a tree. None Returns: Type Description ( obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: View Source def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a.{}' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"get_raster_data"},{"location":"reference/src/gus/weather/","text":"Module src.gus.weather None None View Source # -*- coding: utf-8 -*- import numpy as np class WeatherSim (): \"\"\"The environment objects that simulates the weather.\"\"\" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ): \"\"\"The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\"\" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ): \"\"\"The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\"\" return self . frost_free_days_ref Classes WeatherSim class WeatherSim ( season_length = None , season_var = None ) View Source class WeatherSim () : \" \"\" The environment objects that simulates the weather. \"\" \" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ) : \" \"\" The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\" \" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref Class variables ffdays_mean ffdays_var Methods check_frost_free_days def check_frost_free_days ( self ) The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj: int ): Number of frost free days. Note: Todo: View Source def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"Weather"},{"location":"reference/src/gus/weather/#module-srcgusweather","text":"None None View Source # -*- coding: utf-8 -*- import numpy as np class WeatherSim (): \"\"\"The environment objects that simulates the weather.\"\"\" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ): \"\"\"The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\"\" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ): \"\"\"The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\"\" return self . frost_free_days_ref","title":"Module src.gus.weather"},{"location":"reference/src/gus/weather/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/weather/#weathersim","text":"class WeatherSim ( season_length = None , season_var = None ) View Source class WeatherSim () : \" \"\" The environment objects that simulates the weather. \"\" \" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ) : \" \"\" The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\" \" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"WeatherSim"},{"location":"reference/src/gus/weather/#class-variables","text":"ffdays_mean ffdays_var","title":"Class variables"},{"location":"reference/src/gus/weather/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/weather/#check_frost_free_days","text":"def check_frost_free_days ( self ) The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj: int ): Number of frost free days. Note: Todo: View Source def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"check_frost_free_days"},{"location":"reference/src/impacts/","text":"Module src.impacts None None Sub-modules src.impacts.carbon src.impacts.water","title":"Index"},{"location":"reference/src/impacts/#module-srcimpacts","text":"None None","title":"Module src.impacts"},{"location":"reference/src/impacts/#sub-modules","text":"src.impacts.carbon src.impacts.water","title":"Sub-modules"},{"location":"reference/src/impacts/carbon/","text":"Module src.impacts.carbon None None","title":"Carbon"},{"location":"reference/src/impacts/carbon/#module-srcimpactscarbon","text":"None None","title":"Module src.impacts.carbon"},{"location":"reference/src/impacts/water/","text":"Module src.impacts.water None None","title":"Water"},{"location":"reference/src/impacts/water/#module-srcimpactswater","text":"None None","title":"Module src.impacts.water"}]}