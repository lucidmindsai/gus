{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gus Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis. Installation Install GUS from PyPi: $ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple gus == 0 .1.8 You can use, Poetry as well: $ poetry add gus Development Create a virtualenv by using pyenv, install it first: $ brew install readline xz $ brew install pyenv pyenv-virtualenv Add those to your ~/.bashrc or ~/.zshrc (or any profiler you use) eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" Install a specific python version: $ pyenv install 3 .9.12 -- Pick your Python version ( 3 .8 is available too ) Create a virtualenv: $ pyenv virtualenv 3 .9.12 gus To enable virtualenv: $ pyenv shell gus Now run poetry to setup GUS: $ poetry build Stick to PEP8 rules for code development. To do the checks, install flake8 to your local machine: $ pip3 install flake8 Once you're done with developing on your branch, before pushing your changes, please run: $ flake8 <file_you_changed_or_added> Please fix the errors and warnings if they appear. Testing The code is tested by through pytest , which is included in the requirements.txt . You can manually install it with the command: $ pip3 install pytest And run the tests: $ pytest All tests are in the tests/ folder","title":"Home"},{"location":"#gus","text":"Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis.","title":"gus"},{"location":"#installation","text":"Install GUS from PyPi: $ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple gus == 0 .1.8 You can use, Poetry as well: $ poetry add gus","title":"Installation"},{"location":"#development","text":"Create a virtualenv by using pyenv, install it first: $ brew install readline xz $ brew install pyenv pyenv-virtualenv Add those to your ~/.bashrc or ~/.zshrc (or any profiler you use) eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" Install a specific python version: $ pyenv install 3 .9.12 -- Pick your Python version ( 3 .8 is available too ) Create a virtualenv: $ pyenv virtualenv 3 .9.12 gus To enable virtualenv: $ pyenv shell gus Now run poetry to setup GUS: $ poetry build Stick to PEP8 rules for code development. To do the checks, install flake8 to your local machine: $ pip3 install flake8 Once you're done with developing on your branch, before pushing your changes, please run: $ flake8 <file_you_changed_or_added> Please fix the errors and warnings if they appear.","title":"Development"},{"location":"#testing","text":"The code is tested by through pytest , which is included in the requirements.txt . You can manually install it with the command: $ pip3 install pytest And run the tests: $ pytest All tests are in the tests/ folder","title":"Testing"},{"location":"README-pypi/","text":"gus Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis. install GUS from Test-PyPi import sys ! { sys . executable } - m pip install -- index - url https : // test . pypi . org / simple / -- extra - index - url https : // pypi . org / simple gus == 0.1.7","title":"gus"},{"location":"README-pypi/#gus","text":"Green Urban Scenarios - A digital twin representation, simulation of urban forests and their impact analysis.","title":"gus"},{"location":"README-pypi/#install-gus-from-test-pypi","text":"import sys ! { sys . executable } - m pip install -- index - url https : // test . pypi . org / simple / -- extra - index - url https : // pypi . org / simple gus == 0.1.7","title":"install GUS from Test-PyPi"},{"location":"reference/src/","text":"Module src None None Sub-modules src.gus src.impacts","title":"Index"},{"location":"reference/src/#module-src","text":"None None","title":"Module src"},{"location":"reference/src/#sub-modules","text":"src.gus src.impacts","title":"Sub-modules"},{"location":"reference/src/gus/","text":"Module src.gus None None Sub-modules src.gus.agents src.gus.allometrics src.gus.models src.gus.utilities src.gus.weather","title":"Index"},{"location":"reference/src/gus/#module-srcgus","text":"None None","title":"Module src.gus"},{"location":"reference/src/gus/#sub-modules","text":"src.gus.agents src.gus.allometrics src.gus.models src.gus.utilities src.gus.weather","title":"Sub-modules"},{"location":"reference/src/gus/agents/","text":"Module src.gus.agents None None View Source # -*- coding: utf-8 -*- # Basic Python packages import numpy as np # Mesa Packages from mesa import Agent class Tree ( Agent ): \"\"\"A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\"\" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ): \"\"\"The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \"deciduous\" or \"coniferous\" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\"\" # Initializing parent Class. super () . __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ): \"\"\"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\"\" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ): \"\"\"The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\"\" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ): \"\"\"Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ): \"\"\"Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ): \"\"\"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\"\" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ): \"\"\"A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\"\" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ): \"\"\"The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\"\" def register_death (): self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ): register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ): \"\"\"Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\"\" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ): \"\"\"Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\"\" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \"\"\"The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\"\" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ): \"\"\"The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\"\" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ): \"\"\"The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\"\" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ): \"\"\"The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\"\" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ): self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \"\"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\"\" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id Classes Tree class Tree ( unique_id , model , dbh , species , height = None , kind = 'deciduous' , fixed_sun_exposure = False , condition = None , dieback = None ) View Source class Tree ( Agent ) : \" \"\" A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\" \" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ) : \" \"\" The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \" deciduous \" or \" coniferous \" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\" \" # Initializing parent Class. super (). __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ) : \" \"\" State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ) : \" \"\" Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\" \" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ) : \" \"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ) : \" \"\" Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\" \" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ) : \" \"\" Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\" \" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ) : \" \"\" The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\" \" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ) : \" \"\" The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\" \" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id Ancestors (in MRO) mesa.agent.Agent Class variables carbon_coeff carbon_storage_cap condition_multiplier crown_to_trunk_ratio decomposition_coeff root_to_shoot_ratio sequestration_at_maturity sun_exposure_rates Instance variables random Methods advance def advance ( self ) -> None View Source def advance ( self ) -> None : pass check_dieback def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj: float ): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj: float ): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj: float ): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. View Source def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback compute_biomass def compute_biomass ( self , ignore_height = True ) -> float The biomass calculation for the tree, in KG. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. None Ex None 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): Biomass in Kg. Todo: Update the generic biomass. View Source def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass compute_contagion_risk def compute_contagion_risk ( self ) A very simplified version of contagion. Args: None Returns: (:obj: float ): contagion risk a value within the inclusive range [0,0.9] View Source def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk compute_decomposition def compute_decomposition ( self ) The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. View Source def compute_decomposition ( self ) : \"\" \"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self._reset_release_track() if self.condition == 'dead': self._compute_decomposition_dead() return # the tree is alive self._compute_decomposition_alive() compute_light_exposure def compute_light_exposure ( self ) The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. View Source def compute_light_exposure ( self ) : \"\" \"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self.fixed_sun_exposure: return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self.model.grid.get_neighborhood( self.pos, moore = False, include_center = False, radius = 1) neighboors = self.model.grid.get_cell_list_contents(posns_list) self.overlap_ratio = 0 combined_overlap = 0 for t in neighboors: t_w = t.crown_width t_h = t.tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max(0, 0.5 * (self.crown_width + t_w) - self.model.dt_resolution) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min(1, (overlap / self.crown_width)) # a taller tree creates more shading combined_overlap += overlap_ratio * (t_h / (t_h + self.tree_height)) self.overlap_ratio += overlap_ratio # Cases needs to be inspected self.overlap_ratio = min(1, self.overlap_ratio) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self.cle = max(0, 1 - light_loss_multiplier * combined_overlap) compute_sequestration def compute_sequestration ( self ) The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj: float ): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors View Source def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration estimate_tree_height def estimate_tree_height ( self ) Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) View Source def estimate_tree_height ( self ) : \"\" \"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self.tree_height = self.f_tree_height(self.dbh) return self.tree_height fleming_height def fleming_height ( self ) Updates the tree height based on the model by Fleming (1988) Args: None Returns: None View Source def fleming_height(self): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self.tree_height += Tree.condition_multiplier[self.condition] * 0.15 grow def grow ( self , frost_free_days ) The method updates DBH of the tree. Currently it is an annual growth in cm. Parameters: Name Type Description Default frost_free_days None (:obj: int ): the number of observed frost free days None Returns: Type Description None None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201c maximum \u201d height , growth rate decreases . Thus , the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species . The estimated tree height at maturity is derived from the literature . When a tree \u2019 s height is more than 80 percent of its average height at maturity , the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2 . 22 percent of full growth at 125 percent of height at maturity . Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods | View Source def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () replace def replace ( self ) -> int In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj: int ): new agent id. View Source def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id step def step ( self ) State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None View Source def step ( self ) : \"\" \"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self.condition == 'replaced': return # The tree is dead and its carbon release schedule is accounted. if self.death_acc: self._reset_release_track() if np.random.uniform(0, 1) < self.expected_care: self.replace() return if self.condition == 'dead': self.compute_decomposition() return # check frost free days for the past year. frost_free_days = self.model.WeatherAPI.check_frost_free_days() #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self.compute_light_exposure() # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self.check_dieback() # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self.grow(frost_free_days) # compute the total biomass self.compute_biomass() #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self.compute_sequestration() #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self.compute_decomposition() update_crown_height def update_crown_height ( self ) Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height update_crown_width def update_crown_width ( self ) Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width update_tree_height def update_tree_height ( self , generic = False ) Computes the height of tree based on the species and current dbh. Args: None Returns: None View Source def update_tree_height ( self , generic = False ) : \"\" \"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic: self.fleming_height() return self.tree_height = self.f_tree_height(self.dbh)","title":"Agents"},{"location":"reference/src/gus/agents/#module-srcgusagents","text":"None None View Source # -*- coding: utf-8 -*- # Basic Python packages import numpy as np # Mesa Packages from mesa import Agent class Tree ( Agent ): \"\"\"A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\"\" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ): \"\"\"The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \"deciduous\" or \"coniferous\" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\"\" # Initializing parent Class. super () . __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ): \"\"\"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\"\" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ): \"\"\"The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\"\" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\"\" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ): \"\"\"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\"\" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ): \"\"\"Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ): \"\"\"Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\"\" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ): \"\"\"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\"\" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ): \"\"\"A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\"\" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ): \"\"\"The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\"\" def register_death (): self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ): register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ): \"\"\"Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\"\" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ): \"\"\"Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\"\" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \"\"\"The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\"\" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ): \"\"\"The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\"\" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ): \"\"\"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\"\" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ): \"\"\"The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\"\" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ): \"\"\"The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\"\" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ): self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \"\"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\"\" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"Module src.gus.agents"},{"location":"reference/src/gus/agents/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/agents/#tree","text":"class Tree ( unique_id , model , dbh , species , height = None , kind = 'deciduous' , fixed_sun_exposure = False , condition = None , dieback = None ) View Source class Tree ( Agent ) : \" \"\" A generic Tree agent with basic structural attributes and a growth model. It inherits the generic mesa.Agent class. \"\" \" # Def: Carbon storage cap in sequestration calculations. A tree with that amount of CARBON or above this level # has a constant yearly sequestration which is 25kg/year. # Unit: Kg # Ref: iTree, 2020 carbon_storage_cap = 7500 sequestration_at_maturity = 25 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 # (Chow and Rolfe 1989). carbon_coeff = 0.5 # The coeff is used as the generic decomposition rate of dead portion of a tree. # For more accurate estimates on decompostion revise the methods at Nowak et al. (2002b, 2008) decomposition_coeff = 0.1 # Fixed rates for crown light exposure to sunlight (CLE). # 0.44: Forest conditions with a closed, or nearly closed canopy, # 0.56: Park conditions # 1.0: Open-grown conditions, street trees. # Source: iTree sun_exposure_rates = { 'forest' : 0.44 , 'park' : 0.56 , 'street' : 1.0 , 'pocket' : 0.56 } # Condition multipliers. Used at adjusting growth rates. # Ref: Fleming, 1988, and Nowak 2002b condition_multiplier = { 'excellent' : 1 , 'good' : 1 , 'fair' : 1 , 'poor' : 0.76 , 'critical' : 0.42 , 'dying' : 0.15 , 'dead' : 0 } # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 # Biomass ratio at crown to trunk: Needs validation crown_to_trunk_ratio = 0.05 def __init__ ( self , unique_id , model , dbh , species , height = None , kind = \"deciduous\" , fixed_sun_exposure = False , condition = None , dieback = None ) : \" \"\" The constructor method. Args: unique_id: (:obj:`int`): a unique agent id model: (Mesa.Model): the underlying Mesa model. dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species: (:obj:`str`): species identifier height: (:obj:`float`): The tree height in meters. kind: (:obj:`str`): identifies the kind of tree can be either \" deciduous \" or \" coniferous \" (needles) fixed_sun_exposure: (:obj:`bool`): If sun exposure is fixed or to be checked at each iteration. condition: (:obj:`str`): The health condition of the tree. dieback: (:obj:`float`): The percent (0.1 for 10%, etc) of the tree that is dead. Returns: None \"\" \" # Initializing parent Class. super (). __init__ ( unique_id , model ) # Initializing variables for a Tree. self . model = model self . kind = kind self . species = model . species . fuzzymatching ( species ) self . dbh = dbh self . fixed_sun_exposure = fixed_sun_exposure self . overlap_ratio = 0 # Initialize canonical growth functions self . f_tree_height = self . model . species . get_eqn ( self . species , 'height' ) self . f_biomass = self . model . species . get_eqn_biomass ( self . species ) self . f_crown_width = self . model . species . get_eqn ( self . species , 'crown_width' ) self . f_crown_height = self . model . species . get_eqn ( self . species , 'crown_height' ) # Record initial allometries if height : self . tree_height = height else : self . tree_height = self . f_tree_height ( self . dbh ) self . crown_width = self . f_crown_width ( self . dbh ) self . crown_height = self . f_crown_height ( self . dbh ) # dieback related initializations: # Note: this needs to be handled at the initialization module self . dieback = 0 self . condition = 'excellent' if dieback and condition : self . condition = condition self . dieback = dieback elif dieback : self . condition = self . _get_condition_class ( dieback ) self . dieback = dieback elif condition : self . condition = condition self . dieback = self . _estimate_dieback ( condition ) else : self . dieback = np . random . uniform ( 0 , 0.1 ) self . condition = self . _get_condition_class ( self . dieback ) self . diameter_growth = model . species . get_diameter_growth ( species ) # Slow, moderate and fast growing species respectively. # c(0.23, 0.33, 0.43) in inch/yr Source: https://database.itreetools.org/#/splash # Converted into cm. #Default crown light exposure based on site types. self . cle = Tree . sun_exposure_rates [ self . model . site_type ] # Crown light exposure to sunlight (CLE). # CLE <- c(0.44, 0.56, 1) # (1) Forest conditions with a closed, or nearly closed canopy, # (2) Park conditions # (3) Open-grown conditions. self . average_height_at_maturity = model . species . get_height_at_maturity ( self . species ) # Avg height at maturity for the given species. self . biomass = self . compute_biomass () # In Kg self . carbon_storage = Tree . carbon_coeff * self . biomass # In Kg # Amount of carbon release due to dead portion. self . decomposition = 0 # In Kg # Annual carbon sequestration in Kg. self . annual_gross_carbon_sequestration = 0 self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 self . death_acc = False if model . maintenance_scope == 0 : self . expected_care = 0 elif model . maintenance_scope == 1 : self . expected_care = 0.3 else : self . expected_care = 1.0 def step ( self ) : \" \"\" State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self . condition == 'replaced' : return # The tree is dead and its carbon release schedule is accounted. if self . death_acc : self . _reset_release_track () if np . random . uniform ( 0 , 1 ) < self . expected_care : self . replace () return if self . condition == 'dead' : self . compute_decomposition () return # check frost free days for the past year. frost_free_days = self . model . WeatherAPI . check_frost_free_days () #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self . compute_light_exposure () # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self . check_dieback () # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self . grow ( frost_free_days ) # compute the total biomass self . compute_biomass () #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self . compute_sequestration () #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self . compute_decomposition () def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height () def estimate_tree_height ( self ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self . tree_height = self . f_tree_height ( self . dbh ) return self . tree_height def update_tree_height ( self , generic = False ) : \" \"\" Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic : self . fleming_height () return self . tree_height = self . f_tree_height ( self . dbh ) def fleming_height ( self ) : \" \"\" Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\" \" self . tree_height += Tree . condition_multiplier [ self . condition ] * 0.15 def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width def compute_light_exposure ( self ) : \" \"\" The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self . fixed_sun_exposure : return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) self . overlap_ratio = 0 combined_overlap = 0 for t in neighboors : t_w = t . crown_width t_h = t . tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max ( 0 , 0.5 * ( self . crown_width + t_w ) - self . model . dt_resolution ) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min ( 1 , ( overlap / self . crown_width )) # a taller tree creates more shading combined_overlap += overlap_ratio * ( t_h / ( t_h + self . tree_height )) self . overlap_ratio += overlap_ratio # Cases needs to be inspected self . overlap_ratio = min ( 1 , self . overlap_ratio ) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self . cle = max ( 0 , 1 - light_loss_multiplier * combined_overlap ) # try: # total_dbh = sum([t.dbh for t in cellmates]) # cle = self.dbh / total_dbh # except ZeroDivisionError as err: # print(self.unique_id, err) # cle = 0.56 # self.cle = cle def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback def _get_condition_class ( self , dieback ) : \" \"\" Determines the condition class based percent crown lost. Args: dieback: (:obj:`float`): percent crown lost Returns: (:obj:`str`): condition class. Note: The class brackets are based on Nowak 2002b. \"\" \" if dieback < 0.01 : condition = 'excellent' elif dieback <= 0.10 : condition = 'good' elif dieback <= 0.25 : condition = 'fair' elif dieback <= 0.50 : condition = 'poor' elif dieback <= 0.75 : condition = 'critical' elif dieback <= 0.99 : condition = 'dying' else : condition = 'dead' self . condition = condition return condition def _estimate_dieback ( self , condition ) : \" \"\" Draws a crown dieback ratio based on the condition class. Args: dieback: (:obj:`str`): condition class. Returns: (:obj:`str`): (:obj:`float`): percent crown lost. Note: This is used when percent crown data is missing but condition of of a tree is given a qualitatively. Condition class brackets are based on Nowak 2002b. \"\" \" if condition == 'excellent' : self . dieback = np . random . uniform ( 0 , 0.01 ) elif condition == 'good' : self . dieback = np . random . uniform ( 0.01 , 0.11 ) elif condition == 'fair' : dieback = np . random . uniform ( 0.11 , 0.26 ) elif condition == 'poor' : self . dieback = np . random . uniform ( 0.26 , 0.51 ) elif condition == 'critical' : self . dieback = np . random . uniform ( 0.51 , 0.76 ) elif condition == 'dying' : self . dieback = np . random . uniform ( 0.76 , 0.99 ) else : self . dieback = 1.0 return self . dieback def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass def _reset_release_track ( self ) : \" \"\" The resetting state variables that is being observed by data collectors. Args: None Returns: None \"\" \" self . mulched = 0 self . decomposing_root = 0 self . decomposing_trunk = 0 self . immediate_release = 0 def compute_decomposition ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self . _reset_release_track () if self . condition == 'dead' : self . _compute_decomposition_dead () return # the tree is alive self . _compute_decomposition_alive () def _compute_decomposition_alive ( self ) : \" \"\" The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" to_decompose = Tree . crown_to_trunk_ratio * self . dieback * self . carbon_storage if np . random . uniform ( 0 , 1 ) < 0.9 : self . mulched = to_decompose else : # 100% of the removed dead brunches are burned etc. self . immediate_release = 1.0 * to_decompose def _compute_decomposition_dead ( self ) : \" \"\" The amount of carbon release in KG due to diebacks. Args: None Returns: (:obj:`float`): Amount of carbon release in KG. Todo: This implementation is based on Nowak et al. (2002b, 2008) \"\" \" # self.release = self.decomposition_rate * self.carbon_storage # accounting carbon release process self . death_acc = True self . decomposing_root = Tree . root_to_shoot_ratio * self . carbon_storage decomposable_above_ground = self . carbon_storage - self . decomposing_root # the probability of being removed from the site if np . random . uniform ( 0 , 1 ) < 0.5 : # 70% chance burnt, 30% converted into sustainable products self . immediate_release = 0.7 * decomposable_above_ground return # Not removed from the site: # The probability of standing if np . random . uniform ( 0 , 1 ) < 0.4 : self . decomposing_trunk = decomposable_above_ground else : self . mulched = decomposable_above_ground return def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"Tree"},{"location":"reference/src/gus/agents/#ancestors-in-mro","text":"mesa.agent.Agent","title":"Ancestors (in MRO)"},{"location":"reference/src/gus/agents/#class-variables","text":"carbon_coeff carbon_storage_cap condition_multiplier crown_to_trunk_ratio decomposition_coeff root_to_shoot_ratio sequestration_at_maturity sun_exposure_rates","title":"Class variables"},{"location":"reference/src/gus/agents/#instance-variables","text":"random","title":"Instance variables"},{"location":"reference/src/gus/agents/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/agents/#advance","text":"def advance ( self ) -> None View Source def advance ( self ) -> None : pass","title":"advance"},{"location":"reference/src/gus/agents/#check_dieback","text":"def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj: float ): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj: float ): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj: float ): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. View Source def check_dieback ( self , stochastic = True , risk_rate = 0.005 , healing_rate = 0.005 ) : \" \"\" The dieback calculation for the tree. It is a path dependent. A 'random walk' from latest state is considered. The new rate is drawn from a uniform distribution between -1 * healing_rate and risk_rate. A tree with a dieback ratio 1 can not recover. Args: risk_rate: (:obj:`float`): A mean risk rate used to draw a random dieback ratio. healing_rate: (:obj:`float`): A mean healing rate that is used to model recovery rate of a tree from a sickness. Returns: (:obj:`float`): dieback ratio. Todo: Update the data either using measured dieback for species or a site/species specific distribution function. \"\" \" def register_death () : self . dieback = 1.0 self . condition = 'dead' # The dieback model below is based on Nowak et al (1986, 2002b:p13) # Mortality rate: # 100% for dead trees # 1.96% for good-excellent and DBH < 3inches # 1.46% for good-excellent and DBH > 3inches # 3.32% for fair condition # 8.86% for poor condition # 13.08% for critical condition # 50% for dying condition risk = np . random . uniform ( 0 , 1 ) if self . model . maintenance_scope < 1 : dr = 5 elif self . model . maintenance_scope > 1 : dr = 1 else : dr = 4 if self . dieback >= 1 : register_death () elif self . condition == 'dead' : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh < 7.62 and risk <= 0.0196 * dr : register_death () elif self . condition in ( 'good' , 'excellent' ) and self . dbh >= 7.62 and risk <= 0.0146 * dr : register_death () elif self . condition == 'fair' and risk <= 0.0332 * dr : register_death () elif self . condition == 'poor' and risk <= 0.0886 * dr : register_death () elif self . condition == 'critical' and risk <= 0.1308 * dr : register_death () elif self . condition == 'dying' and risk <= min ( 0.9 , 0.5 * dr ) : register_death () else : # The dieback model below is path dependent and depends on # (i) the latest condition of the tree, # (ii) the age via DBH and # (iii) the health of neighboring trees. # the new rate is drawn from a # uniform distribution between -1 * healing_rate and risk_rate. if stochastic : contagion_risk = self . compute_contagion_risk () #multiplier = Tree.condition_multiplier[self.condition] * np.sqrt(self.dbh) if self . condition == 'excellent' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.001 else : self . dieback += 0.001 elif self . condition == 'good' : if np . random . uniform ( 0 , 1 ) < 0.5 : self . dieback -= 0.005 else : self . dieback += 0.005 else : multiplier = ( 1 - contagion_risk ) * np . sqrt ( self . dbh ) / dr if multiplier > 0.01 : heal_range = - 1 * multiplier * healing_rate die_range = risk_rate / multiplier #die_range = risk_rate self . dieback += np . random . uniform ( heal_range , die_range ) self . dieback = min ( 1 , self . dieback ) self . dieback = max ( 0 , self . dieback ) self . condition = self . _get_condition_class ( self . dieback ) return self . dieback","title":"check_dieback"},{"location":"reference/src/gus/agents/#compute_biomass","text":"def compute_biomass ( self , ignore_height = True ) -> float The biomass calculation for the tree, in KG. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. None Ex None 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): Biomass in Kg. Todo: Update the generic biomass. View Source def compute_biomass ( self , ignore_height = True ) -> float : \" \"\" The biomass calculation for the tree, in KG. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): Biomass in Kg. Todo: Update the generic biomass. \"\" \" self . biomass = self . f_biomass ( self . dbh ) carbon_estimate = self . biomass * Tree . carbon_coeff if carbon_estimate > Tree . carbon_storage_cap : #self.biomass = (1 / Tree.carbon_coeff) * Tree.carbon_storage_cap self . biomass = Tree . carbon_storage_cap return self . biomass","title":"compute_biomass"},{"location":"reference/src/gus/agents/#compute_contagion_risk","text":"def compute_contagion_risk ( self ) A very simplified version of contagion. Args: None Returns: (:obj: float ): contagion risk a value within the inclusive range [0,0.9] View Source def compute_contagion_risk ( self ) : \" \"\" A very simplified version of contagion. Args: None Returns: (:obj:`float`): contagion risk a value within the inclusive range [0,0.9] \"\" \" posns_list = self . model . grid . get_neighborhood ( self . pos , moore = False , include_center = False , radius = 1 ) neighboors = self . model . grid . get_cell_list_contents ( posns_list ) count_neighboors = len ( neighboors ) if count_neighboors == 0 : return 0 contagion_risk = 0 for atree in neighboors : contagion_risk += atree . dieback if count_neighboors > 4 : contagion_risk /= count_neighboors else : contagion_risk /= 4 #TODO: 0.9 is an adjustment parameter that needs calibration. return 0.9 * contagion_risk","title":"compute_contagion_risk"},{"location":"reference/src/gus/agents/#compute_decomposition","text":"def compute_decomposition ( self ) The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. View Source def compute_decomposition ( self ) : \"\" \"The amount of carbon release in KG due to partial diebacks. Args: None Returns: None Todo: This module on carbon release from alive trees due to partial diebacks or crown loss needs to be revised. \"\" \" # self.release = self.decomposition_rate * self.dieback * self.carbon_storage self._reset_release_track() if self.condition == 'dead': self._compute_decomposition_dead() return # the tree is alive self._compute_decomposition_alive()","title":"compute_decomposition"},{"location":"reference/src/gus/agents/#compute_light_exposure","text":"def compute_light_exposure ( self ) The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. View Source def compute_light_exposure ( self ) : \"\" \"The method computes light exposure of a tree on a dynamic manner. The tree checks the state of its neighbouring trees and determines its current CLE. Args: None Returns: None Note: Current version checks out other trees within the same grid. It checks height and width of each neighboring tree. Canopy overlap ratio is used as proxy to determine available CLE. The model assumes that a taller neighbourung tree reduces sun light exposure. Todo: * The assumption needs to be revisited and validated. * The model needs to be revised in case the same location is shared by other species. \"\" \" if self.fixed_sun_exposure: return #cellmates = self.model.grid.get_cell_list_contents([self.pos]) posns_list = self.model.grid.get_neighborhood( self.pos, moore = False, include_center = False, radius = 1) neighboors = self.model.grid.get_cell_list_contents(posns_list) self.overlap_ratio = 0 combined_overlap = 0 for t in neighboors: t_w = t.crown_width t_h = t.tree_height # 0.5 multiplier is a mean multiplier to correct square shaped assumption on tree crown shape. overlap = max(0, 0.5 * (self.crown_width + t_w) - self.model.dt_resolution) # 0.25 multiplier is to account one of the four sides of the grid cell. overlap_ratio = 0.25 * min(1, (overlap / self.crown_width)) # a taller tree creates more shading combined_overlap += overlap_ratio * (t_h / (t_h + self.tree_height)) self.overlap_ratio += overlap_ratio # Cases needs to be inspected self.overlap_ratio = min(1, self.overlap_ratio) light_loss_multiplier = 0.75 # arbitrary to be fixed with empirical data. self.cle = max(0, 1 - light_loss_multiplier * combined_overlap)","title":"compute_light_exposure"},{"location":"reference/src/gus/agents/#compute_sequestration","text":"def compute_sequestration ( self ) The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj: float ): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \"For trees in fair to excellent condition, growth rates were multiplied by 1 (no adjustment), poor trees\u2019 growth rates were multiplied by 0.76, critical trees by 0.42, and dying trees by 0.15 (dead trees\u2019 growth rates = 0). Adjustment factors were based on percent crown dieback and the assumption that less than 25-percent crown dieback had a limited effect on d.b.h. growth rates.\"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors View Source def compute_sequestration ( self ) : \" \"\" The method estimates annual amount of sequestration in Kg. The model is based on Chow and Rolfe (1989) and used by iTree. Args: None Returns: (:obj:`float`): annual sequestration in carbon. Note: The growth of the tree needs to be adjusted for the health condition of a tree \" For trees in fair to excellent condition , growth rates were multiplied by 1 ( no adjustment ), poor trees\u2019 growth rates were multiplied by 0.76 , critical trees by 0.42 , and dying trees by 0.15 ( dead trees\u2019 growth rates = 0 ). Adjustment factors were based on percent crown dieback and the assumption that less than 25 - percent crown dieback had a limited effect on d . b . h . growth rates . \"(Nowak et al, 2002b) The difference in estimates of C storage between year x and year x+1 is the gross amount of C sequestered annually. Todo: - Raise Warning/Error for unexpected behaviors \"\" \" if self . dieback >= 1.0 : self . annual_gross_carbon_sequestration = 0 return self . annual_gross_carbon_sequestration carbon_storage_lag = self . carbon_storage carbon_estimate = self . biomass * Tree . carbon_coeff # min() function prevents carbon storage from over estimation for very # large trees self . carbon_storage = min ( carbon_estimate , Tree . carbon_storage_cap ) if ( carbon_estimate >= Tree . carbon_storage_cap ) : self . annual_gross_carbon_sequestration = Tree . sequestration_at_maturity return self . annual_gross_carbon_sequestration sequestration = self . carbon_storage - carbon_storage_lag # Double check and raise a warning message here. if sequestration < 0 : sequestration = Tree . sequestration_at_maturity self . carbon_storage = carbon_storage_lag self . annual_gross_carbon_sequestration = sequestration return self . annual_gross_carbon_sequestration","title":"compute_sequestration"},{"location":"reference/src/gus/agents/#estimate_tree_height","text":"def estimate_tree_height ( self ) Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) View Source def estimate_tree_height ( self ) : \"\" \"Computes the height of tree based on the species and current dbh. Args: None Returns: None Todo: In case of absence of a height function a generic function is used. Current generic function is based on family of height functions yet still arbitrary. It needs to be updated by the higher level phenotypes (needle, leaf, etc.) \"\" \" self.tree_height = self.f_tree_height(self.dbh) return self.tree_height","title":"estimate_tree_height"},{"location":"reference/src/gus/agents/#fleming_height","text":"def fleming_height ( self ) Updates the tree height based on the model by Fleming (1988) Args: None Returns: None View Source def fleming_height(self): \"\"\"Updates the tree height based on the model by Fleming (1988) Args: None Returns: None \"\"\" self.tree_height += Tree.condition_multiplier[self.condition] * 0.15","title":"fleming_height"},{"location":"reference/src/gus/agents/#grow","text":"def grow ( self , frost_free_days ) The method updates DBH of the tree. Currently it is an annual growth in cm. Parameters: Name Type Description Default frost_free_days None (:obj: int ): the number of observed frost free days None Returns: Type Description None None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201c maximum \u201d height , growth rate decreases . Thus , the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species . The estimated tree height at maturity is derived from the literature . When a tree \u2019 s height is more than 80 percent of its average height at maturity , the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2 . 22 percent of full growth at 125 percent of height at maturity . Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods | View Source def grow ( self , frost_free_days ) : \" \"\" The method updates DBH of the tree. Currently it is an annual growth in cm. Args: frost_free_days: (:obj:`int`): the number of observed frost free days Returns: None Note: Current version uses the growth model, where the number of frost free days and species specific diameter growth factor is sufficient for the growth mode. Site specific and species specific diameter growth needs to be considered. As a tree approaches \u201cmaximum\u201d height, growth rate decreases. Thus,the species growth rates are adjusted based on the ratio between the current height of the tree and the average height at maturity for the species. The estimated tree height at maturity is derived from the literature. When a tree\u2019s height is more than 80 percent of its average height at maturity, the annual diameter growth is proportionally reduced from full growth at 80 percent of maximum height to 2.22 percent of full growth at 125 percent of height at maturity. Todo: The constants in the formulas below needs to be parameterized. References for the current constants: David J. Nowak, 2020. Understanding i-Tree: Summary of Programs and Methods \"\" \" # This equation need to be corrected. Check i-tree paper. height_ratio = self . tree_height / self . average_height_at_maturity if height_ratio >= 1.25 : delta_dbh = 0.0222 elif height_ratio >= 0.8 : # delta_dbh = 0.0222 + ((1 - 0.0222) / (1.25 - 0.8)) * (1.25 - height_ratio) delta_dbh = 0.0222 + 2.1729 * ( 1.25 - height_ratio ) else : delta_dbh = self . diameter_growth * self . cle * ( 1 - self . dieback ) # Adjust the growth rate according to health condition. delta_dbh *= Tree . condition_multiplier [ self . condition ] self . dbh += delta_dbh * ( frost_free_days / 153 ) # Update the tree height based on the updated dbh. self . update_tree_height ( generic = False ) # Update the change at canopy. self . update_crown_width () self . update_crown_height ()","title":"grow"},{"location":"reference/src/gus/agents/#replace","text":"def replace ( self ) -> int In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj: int ): new agent id. View Source def replace ( self ) -> int : \" \"\" In case of a maintenance project in place a new young tree or sapling is planted at the location where the tree is dead. Args: None Returns: (:obj:`int`): new agent id. \"\" \" self . condition = 'replaced' # Replacing with the site specific minimum sapling. dbh = np . random . uniform ( self . model . sapling_dbh , self . model . sapling_dbh + 1 ) id = self . model . next_id () new_tree = Tree ( id , self . model , dbh , self . species , condition = 'excellent' , dieback = 0 ) self . model . grid . place_agent ( new_tree , self . pos ) self . model . schedule . add ( new_tree ) return id","title":"replace"},{"location":"reference/src/gus/agents/#step","text":"def step ( self ) State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None View Source def step ( self ) : \"\" \"State transitions of a given Tree agent. Args: None Returns: None Note: None Todo: None \"\" \" # Once the replaced tree agents are removed from the model, this line will be idle and s # should be removed too. if self.condition == 'replaced': return # The tree is dead and its carbon release schedule is accounted. if self.death_acc: self._reset_release_track() if np.random.uniform(0, 1) < self.expected_care: self.replace() return if self.condition == 'dead': self.compute_decomposition() return # check frost free days for the past year. frost_free_days = self.model.WeatherAPI.check_frost_free_days() #print('Tree: {} checks ffdays = {} ...'.format(self.unique_id, frost_free_days)) # compute the light exposure self.compute_light_exposure() # check state of the health of the tree #print('Tree: {} checks dieback ...'.format(self.unique_id)) self.check_dieback() # compute the growth #print('Tree: {} grows ...'.format(self.unique_id)) self.grow(frost_free_days) # compute the total biomass self.compute_biomass() #print('Tree: {} biomass ...'.format(self.unique_id)) # compute the amount of new carbon sequestration self.compute_sequestration() #print('Tree: {} sequestration ...'.format(self.unique_id)) # compute the amount of carbon release due to decomposition #print('Tree: {} decomposition ...'.format(self.unique_id)) self.compute_decomposition()","title":"step"},{"location":"reference/src/gus/agents/#update_crown_height","text":"def update_crown_height ( self ) Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_height ( self ) : \" \"\" Computes the vertical length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_height = self . f_crown_height ( self . dbh ) return self . crown_height","title":"update_crown_height"},{"location":"reference/src/gus/agents/#update_crown_width","text":"def update_crown_width ( self ) Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj: float ): Current crown width in meters View Source def update_crown_width ( self ) : \" \"\" Computes the horizontal length of the tree crown based on the species and its current dbh. Args: None Returns: (:obj:`float`): Current crown width in meters \"\" \" self . crown_width = self . f_crown_width ( self . dbh ) return self . crown_width","title":"update_crown_width"},{"location":"reference/src/gus/agents/#update_tree_height","text":"def update_tree_height ( self , generic = False ) Computes the height of tree based on the species and current dbh. Args: None Returns: None View Source def update_tree_height ( self , generic = False ) : \"\" \"Computes the height of tree based on the species and current dbh. Args: None Returns: None \"\" \" if generic: self.fleming_height() return self.tree_height = self.f_tree_height(self.dbh)","title":"update_tree_height"},{"location":"reference/src/gus/allometrics/","text":"Module src.gus.allometrics None None View Source # -*- coding: utf-8 -*- # Importing Python Libraries import numpy as np import json from fuzzywuzzy import process class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric Classes Species class Species ( species_db ) View Source class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @ staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric Class variables root_to_shoot_ratio Static methods filter_dbh_size def filter_dbh_size ( dbh , minv , maxv ) Utility function to assure the range of dbh that can be used by the growth functions View Source @staticmethod def filter_dbh_size ( dbh , minv , maxv ) : \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) fit_exponential def fit_exponential ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp fit_parametric def fit_parametric ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric fit_polynomial def fit_polynomial ( params ) Static method that sets the constant of a second degree polynomial function. View Source @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol Methods fuzzymatching def fuzzymatching ( self , species ) Fuzzy matching species name. Parameters: Name Type Description Default species None (:obj: string ): name of the species None Returns: Type Description ( obj: string ): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. | View Source def fuzzymatching ( self , species ) : \" \"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\" \" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest get_diameter_growth def get_diameter_growth ( self , species ) Retrieve annual avg diameter growth rate for the site for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): the standard growth per year in cm. View Source def get_diameter_growth ( self , species ) : \" \"\" Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 get_eqn def get_eqn ( self , species_name , allometry_type ) The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: f(string)->float ): the growth function View Source def get_eqn ( self , species_name , allometry_type ) : \" \"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\" \" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) get_eqn_biomass def get_eqn_biomass ( self , species_name ) The method retrieves constants of a bimomass function for the given species and returns the species specific function. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None Returns: Type Description ( obj: f(string)->float ): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. View Source def get_eqn_biomass ( self , species_name ) : \" \"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\" \" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) get_form_and_constants def get_form_and_constants ( self , species_name , allometry_type ) The method retrieves parameters and type of a growth function for the given species. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: (string, dict ) View Source def get_form_and_constants ( self , species_name , allometry_type ) : \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) get_height_at_maturity def get_height_at_maturity ( self , species ) Observed avg total height of the tree for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: int ): Avg height in meters. View Source def get_height_at_maturity ( self , species ) : \" \"\" Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 list_species def list_species ( self ) List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj: list of String ): List of species names. View Source def list_species ( self ) : \" \"\" List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\" \" return list ( self . parameters . keys ())","title":"Allometrics"},{"location":"reference/src/gus/allometrics/#module-srcgusallometrics","text":"None None View Source # -*- coding: utf-8 -*- # Importing Python Libraries import numpy as np import json from fuzzywuzzy import process class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"Module src.gus.allometrics"},{"location":"reference/src/gus/allometrics/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/allometrics/#species","text":"class Species ( species_db ) View Source class Species (): \"\"\"Object that holds standard tree growth rate by species at different sites. Source: https://database.itreetools.org/#/speciesSearch Todo: Consider to convert this into a db or API. \"\"\" # Ref: Root to shoot ratio (Cairns et al. 1997) root_to_shoot_ratio = 0.26 def __init__ ( self , species_db ): \"\"\"The constructor method. Args: species_db: (:obj:`str`): File name that holds parameters for allometrics of the species used in the models. Eg:'./gus/inpurs/allometrics.json' Returns: None \"\"\" species_filename = species_db f = open ( species_filename ) self . parameters = json . loads ( f . read ()) def get_diameter_growth ( self , species ): \"\"\"Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382 def get_height_at_maturity ( self , species ): \"\"\"Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\"\" if species in self . parameters . keys (): return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25 def list_species ( self ): \"\"\"List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\"\" return list ( self . parameters . keys ()) def fuzzymatching ( self , species ): \"\"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\"\" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest def get_eqn ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\"\" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type )) def get_eqn_biomass ( self , species_name ): \"\"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\"\" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio ) def get_form_and_constants ( self , species_name , allometry_type ): \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params ) @ staticmethod def filter_dbh_size ( dbh , minv , maxv ): \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh ) @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"Species"},{"location":"reference/src/gus/allometrics/#class-variables","text":"root_to_shoot_ratio","title":"Class variables"},{"location":"reference/src/gus/allometrics/#static-methods","text":"","title":"Static methods"},{"location":"reference/src/gus/allometrics/#filter_dbh_size","text":"def filter_dbh_size ( dbh , minv , maxv ) Utility function to assure the range of dbh that can be used by the growth functions View Source @staticmethod def filter_dbh_size ( dbh , minv , maxv ) : \"\"\"Utility function to assure the range of dbh that can be used by the growth functions \"\"\" # converting the dbh in cm into inche dbh = max ( minv , 0.393700787 * dbh ) return min ( maxv , dbh )","title":"filter_dbh_size"},{"location":"reference/src/gus/allometrics/#fit_exponential","text":"def fit_exponential ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_exponential ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_exp ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = np . exp ( B0 + B1 * np . log ( dbh )) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_exp","title":"fit_exponential"},{"location":"reference/src/gus/allometrics/#fit_parametric","text":"def fit_parametric ( params ) Static method that sets the constant of the exponential function. View Source @ staticmethod def fit_parametric ( params ): \"\"\"Static method that sets the constant of the exponential function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] def fit_parametric ( dbh ): estimate = B0 + B1 * ( dbh ** B2 ) return max ( 0 , estimate ) return fit_parametric","title":"fit_parametric"},{"location":"reference/src/gus/allometrics/#fit_polynomial","text":"def fit_polynomial ( params ) Static method that sets the constant of a second degree polynomial function. View Source @ staticmethod def fit_polynomial ( params ): \"\"\"Static method that sets the constant of a second degree polynomial function. \"\"\" B0 = params [ 'B0' ] B1 = params [ 'B1' ] B2 = params [ 'B2' ] DBHMin = params [ 'DBHMin' ] DBHMax = params [ 'DBHMax' ] def fit_pol ( dbh ): # converting the dbh in cm into inche dbh = min ( DBHMax , max ( DBHMin , 0.393700787 * dbh )) estimate = B0 + ( B1 * dbh ) + ( B2 * dbh * dbh ) # converting into meters return max ( 0 , 0.3048 * estimate ) return fit_pol","title":"fit_polynomial"},{"location":"reference/src/gus/allometrics/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/allometrics/#fuzzymatching","text":"def fuzzymatching ( self , species ) Fuzzy matching species name. Parameters: Name Type Description Default species None (:obj: string ): name of the species None Returns: Type Description ( obj: string ): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. | View Source def fuzzymatching ( self , species ) : \" \"\" Fuzzy matching species name. Args: species: (:obj:`string`): name of the species Returns: (:obj:`string`): Species name in 'genusName_speciesName' format that has highest matching score. Note: If the best matching has a poor score (<10% similarity) then betula_pendula is passed on as default. \"\" \" highest , score = process . extractOne ( species , self . list_species ()) if score < 10 : highest = 'betula_pendula' return highest","title":"fuzzymatching"},{"location":"reference/src/gus/allometrics/#get_diameter_growth","text":"def get_diameter_growth ( self , species ) Retrieve annual avg diameter growth rate for the site for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: float ): the standard growth per year in cm. View Source def get_diameter_growth ( self , species ) : \" \"\" Retrieve annual avg diameter growth rate for the site for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`float`): the standard growth per year in cm. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'diameter_growth' ] else : # Return moderate growth rate. return 0.8382","title":"get_diameter_growth"},{"location":"reference/src/gus/allometrics/#get_eqn","text":"def get_eqn ( self , species_name , allometry_type ) The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: f(string)->float ): the growth function View Source def get_eqn ( self , species_name , allometry_type ) : \" \"\" The method retrieves parameters of a given growth function and sets its constant paramters and returns a function to be used by the tree agents. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`f(string)->float`): the growth function \"\" \" eq_type , params = self . get_form_and_constants ( species_name , allometry_type ) if eq_type == 'exponential' : return Species . fit_exponential ( params ) elif eq_type == 'polynomial' : return Species . fit_polynomial ( params ) elif eq_type == 'parametric' : return Species . fit_parametric ( params ) else : raise NameError ( 'Equation {} for {} type is not implemented.' . format ( eq_type , allometry_type ))","title":"get_eqn"},{"location":"reference/src/gus/allometrics/#get_eqn_biomass","text":"def get_eqn_biomass ( self , species_name ) The method retrieves constants of a bimomass function for the given species and returns the species specific function. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None Returns: Type Description ( obj: f(string)->float ): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. View Source def get_eqn_biomass ( self , species_name ) : \" \"\" The method retrieves constants of a bimomass function for the given species and returns the species specific function. Args: species_name: (:obj:`string`): name of the species Returns: (:obj:`f(string)->float`): the biomass function Note: Refactoring note: Consider to re implement this by the generic function above. \"\" \" eq_type , params = self . get_form_and_constants ( species_name , 'biomass' ) A = params [ 'A' ] B = params [ 'B' ] C = params [ 'C' ] if eq_type == 'mass_1' : return lambda dbh : 1.0 * ( np . e ** ( A + B * np . log ( dbh ) + C / 2 )) / ( 1 - Species . root_to_shoot_ratio ) elif eq_type == 'mass_2' : return lambda dbh : 1.0 * ( A * pow ( dbh , B + C )) / ( 1 - Species . root_to_shoot_ratio )","title":"get_eqn_biomass"},{"location":"reference/src/gus/allometrics/#get_form_and_constants","text":"def get_form_and_constants ( self , species_name , allometry_type ) The method retrieves parameters and type of a growth function for the given species. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species None allometry_type None (:obj: string ): type of of growth can be height, canopy_width canopy_height. None Returns: Type Description ( obj: (string, dict ) View Source def get_form_and_constants ( self , species_name , allometry_type ) : \"\"\" The method retrieves parameters and type of a growth function for the given species. Args: species_name: (:obj:`string`): name of the species allometry_type: (:obj:`string`): type of of growth can be height, canopy_width canopy_height. Returns: (:obj:`(string, dict`) \"\"\" form = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'equation_type' ] params = self . parameters [ species_name ][ 'equations' ][ allometry_type ][ 'params' ] return ( form , params )","title":"get_form_and_constants"},{"location":"reference/src/gus/allometrics/#get_height_at_maturity","text":"def get_height_at_maturity ( self , species ) Observed avg total height of the tree for the given species. Parameters: Name Type Description Default species None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex None 'picea_abies'. Use the iTree naming scheme None https://database.itreetools.org/#/speciesSearch None Returns: Type Description ( obj: int ): Avg height in meters. View Source def get_height_at_maturity ( self , species ) : \" \"\" Observed avg total height of the tree for the given species. Args: species: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: (:obj:`int`): Avg height in meters. \"\" \" if species in self . parameters . keys () : return self . parameters [ species ][ 'height_at_maturity' ] else : # Return moderate growth rate. return 25","title":"get_height_at_maturity"},{"location":"reference/src/gus/allometrics/#list_species","text":"def list_species ( self ) List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj: list of String ): List of species names. View Source def list_species ( self ) : \" \"\" List existing species whose carbon related parameters exist within the library. Args: None Returns: (:obj:`list` of `String`): List of species names. \"\" \" return list ( self . parameters . keys ())","title":"list_species"},{"location":"reference/src/gus/models/","text":"Module src.gus.models None None View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # Importing Python Libraries import site import numpy as np from functools import reduce import json import logging # Importing necessary Mesa packages from mesa import Model from mesa.time import RandomActivation from mesa.space import MultiGrid from mesa.datacollection import DataCollector # Importing needed GUS objects from .agents import Tree from .allometrics import Species from .weather import WeatherSim class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year: {} \" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a. {} ' . format ( var )) for a in model . schedule . agents ], init ) @staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a. {} ' . format ( memory )) for a in model . schedule . agents ]))) @staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) Classes Urban class Urban ( population , species_composition , site_config , scenario , batch = False ) View Source class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year:{}\" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) @ staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a.{}' . format ( memory )) for a in model . schedule . agents ]))) @ staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @ staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @ staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @ staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) Ancestors (in MRO) mesa.model.Model Class variables dt_resolution site_types Static methods agg_std_sequestration def agg_std_sequestration ( model ) The function estimates the standard deviation for yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. View Source @staticmethod def agg_std_sequestration ( model ) : \" \"\" The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) aggregate def aggregate ( model , var , func =< function Urban .< lambda > at 0x12e436160 > , init = 0 ) A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. View Source @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) aggregate_sequestration def aggregate_sequestration ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def aggregate_sequestration ( model ) : \" \"\" The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) compute_carbon_release_rate def compute_carbon_release_rate ( year , state = 'fast' ) Determines a carbon release rate. Parameters: Name Type Description Default year None (:obj: int ) or (:obj: float ): time passed since the biomass is dead. None state None (:obj: str ): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) None Returns: Type Description ( obj: float ): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts . The shape of function assures a unit integral as time goes to infinity . When k = 2 , in the first 3 years around 60 % is released , which corresponds to empirical findings for mulched biomass above ground . When k = 5 , in the first 3 years around 40 % is released , which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots . check : import scipy.integrate as integrate integrate . quad ( f , 0 , 20 ) > 0.96 for k in ( 2 : 5 ) . | View Source @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ) : \" \"\" Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\" \" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k ) compute_current_carbon_release def compute_current_carbon_release ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def compute_current_carbon_release ( model ) : \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np . array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ] , 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ] , 1 ) # aggregate required type of release ( mulched , etc ) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ) : carbon_release = 0 for i in range ( len ( model . release_bins [ type ] )) : mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate count def count ( model , memory , predicate ) A higher order function for counting agents that satisfy a specific attribute. View Source @staticmethod def count ( model , memory , predicate ) : \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval( 'a.{}'.format(memory)) for a in model.schedule.agents ] ))) Methods get_weather_projection def get_weather_projection ( self ) The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. View Source def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) next_id def next_id ( self ) -> int Return the next unique ID for agents, increment current_id View Source def next_id ( self ) -> int : \"\"\"Return the next unique ID for agents, increment current_id\"\"\" self . current_id += 1 return self . current_id reset_randomizer def reset_randomizer ( self , seed : Union [ int , NoneType ] = None ) -> None Reset the model random number generator. Parameters: Name Type Description Default seed None A new seed for the RNG; if None, reset using the current seed None View Source def reset_randomizer ( self , seed : Optional [ int ] = None ) -> None : \"\"\"Reset the model random number generator. Args: seed: A new seed for the RNG; if None, reset using the current seed \"\"\" if seed is None : seed = self . _seed self . random . seed ( seed ) self . _seed = seed run_model def run_model ( self ) -> None Run the model until the end condition is reached. Overload as needed. View Source def run_model ( self ) -> None : \"\"\"Run the model until the end condition is reached. Overload as needed. \"\"\" while self . running : self . step () step def step ( self ) Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: View Source def step(self): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging.info(\"Year:{}\".format(self.schedule.time + 1)) self.get_weather_projection() logging.info(\"Agents are working ...\") self.schedule.step() logging.info(\"Yearly data is being collected ...\") self.datacollector.collect(self)","title":"Models"},{"location":"reference/src/gus/models/#module-srcgusmodels","text":"None None View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # Importing Python Libraries import site import numpy as np from functools import reduce import json import logging # Importing necessary Mesa packages from mesa import Model from mesa.time import RandomActivation from mesa.space import MultiGrid from mesa.datacollection import DataCollector # Importing needed GUS objects from .agents import Tree from .allometrics import Species from .weather import WeatherSim class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year: {} \" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a. {} ' . format ( var )) for a in model . schedule . agents ], init ) @staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a. {} ' . format ( memory )) for a in model . schedule . agents ]))) @staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"Module src.gus.models"},{"location":"reference/src/gus/models/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/models/#urban","text":"class Urban ( population , species_composition , site_config , scenario , batch = False ) View Source class Urban ( Model ): \"\"\"A generic urban green space model. To be tailored according to specific sites. \"\"\" # Used to hold the scaling of actual physical space within the digital space. # It shows the size of each cell (square) in meters. # TODO: this needs to be brought up as a parameter and placed within the groups # of parameters that handle physical to digital twin mapping. dt_resolution = 2 #in meters site_types = [ 'park' , 'street' , 'forest' , 'pocket' ] def __init__ ( self , population , species_composition , site_config , scenario , batch = False ): \"\"\"The constructor method. Args: population: (:obj:`pd.DataFrame`): A dataframe tree properties are read from a site. species_composition (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. site_config: (:obj:`string`): name of the json file. scenario: (:obj:`dict`): Python dictionary that holds experiment parameters. batch: (:obj:`bool`): Mesa parameter to control single vs batch runs. Returns: None Note: First release model. Todo: Check for hard coded constants and parameterize further. \"\"\" super () . __init__ () # Setting MESA specific parameters width = int ( max ( population . xpos )) + 1 height = int ( max ( population . ypos )) + 1 self . grid = MultiGrid ( width , height , torus = False ) # to be parameterized and set during initialization. self . schedule = RandomActivation ( self ) self . _load_site_parameters ( site_config ) self . _load_experiment_parameters ( scenario ) # Load species composition and their allometrics self . species = Species ( species_composition ) # will be used by agents. # Test that the df is complete or raise keyerror for attribute in [ 'dbh' , 'species' , 'condition' , 'xpos' , 'ypos' ]: population [ attribute ] # copy and import df self . df = population self . num_agents = len ( population ) self . sapling_dbh = min ( population . dbh ) # Each entry index i, represents number of years since the biomass is decay period. self . release_bins = { 'slow' : np . zeros ( 10 ), # for dead root and standing tree. 'fast' : np . zeros ( 10 ) # for mulched biomass } # Create agents. for index , row in self . df . iterrows (): # Tree init a = Tree ( row . id , self , dbh = row . dbh , species = row . species , condition = row . condition ) self . schedule . add ( a ) # Place trees on the plot sequentially # based on their id/index. # TODO: This snippet may need to be converted into a function as part of # initilisartion module and x,y points need to be part of input DB. #x = int(index % self.grid.width) #y = int(index / self.grid.height) # # Add the agent to a random grid cell #x = self.random.randrange(self.grid.width) #y = self.random.randrange(self.grid.height) # # Locate the trees based on actual physical positioning x = row . xpos y = row . ypos self . grid . place_agent ( a , ( x , y )) # This variable below works as an indexer while adding new trees to the population during the run time. self . current_id = max ( population . id ) # Collecting model and agent level data self . datacollector = DataCollector ( model_reporters = { \"Storage\" : lambda m : self . aggregate ( m , 'carbon_storage' ), \"Seq\" : lambda m : self . aggregate ( m , 'annual_gross_carbon_sequestration' ), # \"Sequestrated\": self.aggregate_sequestration, \"Released\" : self . compute_current_carbon_release , \"Alive\" : lambda m : self . count ( m , 'condition' , lambda x : x in [ 'excellent' , 'good' , 'fair' , 'poor' , 'critical' , 'dying' ]), \"Dead\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dead' ), \"Critical\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'critical' ), \"Dying\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'dying' ), \"Poor\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'poor' ), \"Replaced\" : lambda m : self . count ( m , 'condition' , lambda x : x == 'replaced' ), \"Seq_std\" : self . agg_std_sequestration , }, agent_reporters = { \"species\" : 'species' , \"dbh\" : 'dbh' , \"height\" : 'tree_height' , \"crownH\" : 'crown_height' , \"crownW\" : 'crown_width' , \"canopy_overlap\" : \"overlap_ratio\" , \"cle\" : \"cle\" , \"condition\" : 'condition' , \"dieback\" : 'dieback' , \"biomass\" : 'biomass' , \"seq\" : 'annual_gross_carbon_sequestration' , \"carbon\" : \"carbon_storage\" , \"deroot\" : 'decomposing_root' , \"detrunk\" : 'decomposing_trunk' , \"mulched\" : 'mulched' , \"burnt\" : 'immediate_release' , \"coordinates\" : 'pos' ,}) logging . info ( \"Initialisation of the Digital Twins of {} trees on a {} by {} digital space is complete!\" . format ( self . num_agents , width , height )) def step ( self ): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging . info ( \"Year:{}\" . format ( self . schedule . time + 1 )) self . get_weather_projection () logging . info ( \"Agents are working ...\" ) self . schedule . step () logging . info ( \"Yearly data is being collected ...\" ) self . datacollector . collect ( self ) # print('Step:{}'.format(self.schedule.time)) # print(self.release_bins['slow']) # print(self.release_bins['fast']) def _load_experiment_parameters ( self , experiment ): \"\"\"Loads site configuration information. Args: experiment: (:obj:`dict`): Python dictionary that holds experiment parameters. Returns: None Todo: \"\"\" # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'maintenance_scope' in experiment . keys (): #maintenance_scope: (:obj:`int`): It can be 0:None,1:base, 2:cared) self . maintenance_scope = experiment [ 'maintenance_scope' ] else : logging . warning ( \"Maintenance scope is not given. A high maintenance site is assumed.\" ) self . maintenance_scope = 2 def _load_site_parameters ( self , config_file ): \"\"\"Loads site configuration information. Args: config_file: (:obj:`string`): name of the json file. Returns: None Todo: \"\"\" try : f = open ( config_file ) except IOError as e : print ( str ( e )) params = json . loads ( f . read ()) #read site type stype = 'park' #default type if 'project_site_type' in params . keys (): if params [ 'project_site_type' ] in Urban . site_types : stype = params [ 'project_site_type' ] else : logging . warning ( \"Undefined site type recognized. Park type will be used.\" ) else : logging . warning ( \"Site type is not provided. Park type will be used.\" ) self . site_type = stype # Read in growth season mean and variance to be used by weather forecasting module. try : self . season_mean = params [ 'weather' ][ 'growth_season_mean' ] self . season_var = params [ 'weather' ][ 'growth_season_var' ] except KeyError : self . season_mean = 153 self . season_var = 7 logging . warning ( \"Tree growth season mean and variance is not provided as expected. Global average is used.\" ) # Read denisty to set the digital twin resolution which is defined as # the cell size in terms of actual distance. if 'area_tree_density_per_hectare' in params . keys (): self . dt_resolution = np . sqrt ( 10000 / params [ 'area_tree_density_per_hectare' ]) # The distance between the center of two tree trunks in meters. Even spatial distribution is assumed. else : logging . warning ( \"area_tree_density_per_hectare is not given the default {} meters is used the distance from the clossest tree trunks.\" . format ( self . dt_resolution )) def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var ) @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init ) @ staticmethod def count ( model , memory , predicate ): \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval ( 'a.{}' . format ( memory )) for a in model . schedule . agents ]))) @ staticmethod def aggregate_sequestration ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured ) @ staticmethod def agg_std_sequestration ( model ): \"\"\"The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\"\" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured ) @ staticmethod def compute_current_carbon_release ( model ): \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np.array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ], 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ], 1 ) # aggregate required type of release (mulched, etc) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ): carbon_release = 0 for i in range ( len ( model . release_bins [ type ])): mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate @ staticmethod def compute_carbon_release_rate ( year , state = 'fast' ): \"\"\"Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\"\" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"Urban"},{"location":"reference/src/gus/models/#ancestors-in-mro","text":"mesa.model.Model","title":"Ancestors (in MRO)"},{"location":"reference/src/gus/models/#class-variables","text":"dt_resolution site_types","title":"Class variables"},{"location":"reference/src/gus/models/#static-methods","text":"","title":"Static methods"},{"location":"reference/src/gus/models/#agg_std_sequestration","text":"def agg_std_sequestration ( model ) The function estimates the standard deviation for yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. View Source @staticmethod def agg_std_sequestration ( model ) : \" \"\" The function estimates the standard deviation for yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return np . std ( captured )","title":"agg_std_sequestration"},{"location":"reference/src/gus/models/#aggregate","text":"def aggregate ( model , var , func =< function Urban .< lambda > at 0x12e436160 > , init = 0 ) A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. View Source @ staticmethod def aggregate ( model , var , func = lambda x , y : x + y , init = 0 ): \"\"\"A higher order function that aggregates a given variable. The aggregation function and the initial conditions can be specified. \"\"\" return reduce ( func , [ eval ( 'a.{}' . format ( var )) for a in model . schedule . agents ], init )","title":"aggregate"},{"location":"reference/src/gus/models/#aggregate_sequestration","text":"def aggregate_sequestration ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def aggregate_sequestration ( model ) : \" \"\" The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\" \" captured = [ a . annual_gross_carbon_sequestration for a in model . schedule . agents ] return sum ( captured )","title":"aggregate_sequestration"},{"location":"reference/src/gus/models/#compute_carbon_release_rate","text":"def compute_carbon_release_rate ( year , state = 'fast' ) Determines a carbon release rate. Parameters: Name Type Description Default year None (:obj: int ) or (:obj: float ): time passed since the biomass is dead. None state None (:obj: str ): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) None Returns: Type Description ( obj: float ): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts . The shape of function assures a unit integral as time goes to infinity . When k = 2 , in the first 3 years around 60 % is released , which corresponds to empirical findings for mulched biomass above ground . When k = 5 , in the first 3 years around 40 % is released , which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots . check : import scipy.integrate as integrate integrate . quad ( f , 0 , 20 ) > 0.96 for k in ( 2 : 5 ) . | View Source @staticmethod def compute_carbon_release_rate ( year , state = 'fast' ) : \" \"\" Determines a carbon release rate. Args: year: (:obj:`int`) or (:obj:`float`): time passed since the biomass is dead. state: (:obj:`str`): Represents exposure type can be one of ('standing', 'mulched', 'root', 'fast', 'slow',) Returns: (:obj:`float`): decay rate. Note: The function computes the release rate based on the time spent since the total carbon within biomass of a dead tree or its parts. The shape of function assures a unit integral as time goes to infinity. When k = 2, in the first 3 years around 60% is released, which corresponds to empirical findings for mulched biomass above ground. When k = 5, in the first 3 years around 40% is released, which corresponds to empirical reports for carbon release for standing dead trees as well as underground roots. check: import scipy.integrate as integrate integrate.quad(f, 0, 20) > 0.96 for k in (2:5). \"\" \" k = 2 if state in ( 'mulched' , 'fast' ) else 5 return 1 / k * np . exp ( - 1 * year / k )","title":"compute_carbon_release_rate"},{"location":"reference/src/gus/models/#compute_current_carbon_release","text":"def compute_current_carbon_release ( model ) The function that accumulates yearly sequestration data from all trees within the site. Parameters: Name Type Description Default model None (:obj: Urban ): an urban forest model. None Returns: Type Description ( obj:float`): total sequestration in Kg. Note: Todo: View Source @staticmethod def compute_current_carbon_release ( model ) : \"\"\"The function that accumulates yearly sequestration data from all trees within the site. Args: model: (:obj:`Urban`): an urban forest model. Returns: (:obj:float`): total sequestration in Kg. Note: Todo: \"\"\" # roll current bins stored as np . array model . release_bins [ 'slow' ] = np . roll ( model . release_bins [ 'slow' ] , 1 ) model . release_bins [ 'fast' ] = np . roll ( model . release_bins [ 'fast' ] , 1 ) # aggregate required type of release ( mulched , etc ) mulched = Urban . aggregate ( model , 'mulched' ) standing = Urban . aggregate ( model , 'decomposing_trunk' ) root = Urban . aggregate ( model , 'decomposing_root' ) immediate = Urban . aggregate ( model , 'immediate_release' ) # add new potential releases into release bins model . release_bins [ 'slow' ][ 0 ] = standing + root model . release_bins [ 'fast' ][ 0 ] = mulched # compute and aggregate release def update_release ( type ) : carbon_release = 0 for i in range ( len ( model . release_bins [ type ] )) : mass = model . release_bins [ type ][ i ] rate = Urban . compute_carbon_release_rate ( i + 1 , type ) released = rate * mass carbon_release += released model . release_bins [ type ][ i ] -= released return carbon_release carbon_release_slow = update_release ( 'slow' ) carbon_release_fast = update_release ( 'fast' ) return carbon_release_fast + carbon_release_slow + immediate","title":"compute_current_carbon_release"},{"location":"reference/src/gus/models/#count","text":"def count ( model , memory , predicate ) A higher order function for counting agents that satisfy a specific attribute. View Source @staticmethod def count ( model , memory , predicate ) : \"\"\"A higher order function for counting agents that satisfy a specific attribute.\"\"\" return len ( list ( filter ( predicate , [ eval( 'a.{}'.format(memory)) for a in model.schedule.agents ] )))","title":"count"},{"location":"reference/src/gus/models/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/models/#get_weather_projection","text":"def get_weather_projection ( self ) The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. View Source def get_weather_projection ( self ): \"\"\"The method retrieves wetaher projection for the current iteration, eg. year, at the moment it uses a simulated projections on the go, instead previously computed estimates or forecasts can be used as well. Args: None Returns: None Note: The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) These variables need to be parameterrized and read-in through site (model) specific initialization module. Todo: * Implement a site initialization method that sets the initial parameters and tree specific variables. \"\"\" # The avg season length is based on iTree Glasgow estimates (see iTree 2015 report) # These variables need to be parameterrized and read-in through site (model) specific # initialization module. # season_mean = 200 self . WeatherAPI = WeatherSim ( season_length = self . season_mean , season_var = self . season_var )","title":"get_weather_projection"},{"location":"reference/src/gus/models/#next_id","text":"def next_id ( self ) -> int Return the next unique ID for agents, increment current_id View Source def next_id ( self ) -> int : \"\"\"Return the next unique ID for agents, increment current_id\"\"\" self . current_id += 1 return self . current_id","title":"next_id"},{"location":"reference/src/gus/models/#reset_randomizer","text":"def reset_randomizer ( self , seed : Union [ int , NoneType ] = None ) -> None Reset the model random number generator. Parameters: Name Type Description Default seed None A new seed for the RNG; if None, reset using the current seed None View Source def reset_randomizer ( self , seed : Optional [ int ] = None ) -> None : \"\"\"Reset the model random number generator. Args: seed: A new seed for the RNG; if None, reset using the current seed \"\"\" if seed is None : seed = self . _seed self . random . seed ( seed ) self . _seed = seed","title":"reset_randomizer"},{"location":"reference/src/gus/models/#run_model","text":"def run_model ( self ) -> None Run the model until the end condition is reached. Overload as needed. View Source def run_model ( self ) -> None : \"\"\"Run the model until the end condition is reached. Overload as needed. \"\"\" while self . running : self . step ()","title":"run_model"},{"location":"reference/src/gus/models/#step","text":"def step ( self ) Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: View Source def step(self): \"\"\"Customized MESA method that sets the major components of scenario analyses process. Args: None Returns: None Note: Todo: \"\"\" logging.info(\"Year:{}\".format(self.schedule.time + 1)) self.get_weather_projection() logging.info(\"Agents are working ...\") self.schedule.step() logging.info(\"Yearly data is being collected ...\") self.datacollector.collect(self)","title":"step"},{"location":"reference/src/gus/utilities/","text":"Module src.gus.utilities None None View Source # -*- coding: utf-8 -*- from functools import reduce import numpy as np def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a. {} ' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster Functions get_raster_data def get_raster_data ( dtwin , var = 'unique_id' , probe =< function < lambda > at 0x12e43c820 > , predicate =< function < lambda > at 0x12e43c790 > , init = 0 , counts = False ) A general purpose function that collects celular data on the grid. Parameters: Name Type Description Default dtwin None (:obj: Urban ): an urban forest model. None var None (:obj: string ): a valid memory variable of a tree. None Returns: Type Description ( obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: View Source def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a.{}' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"Utilities"},{"location":"reference/src/gus/utilities/#module-srcgusutilities","text":"None None View Source # -*- coding: utf-8 -*- from functools import reduce import numpy as np def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a. {} ' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"Module src.gus.utilities"},{"location":"reference/src/gus/utilities/#functions","text":"","title":"Functions"},{"location":"reference/src/gus/utilities/#get_raster_data","text":"def get_raster_data ( dtwin , var = 'unique_id' , probe =< function < lambda > at 0x12e43c820 > , predicate =< function < lambda > at 0x12e43c790 > , init = 0 , counts = False ) A general purpose function that collects celular data on the grid. Parameters: Name Type Description Default dtwin None (:obj: Urban ): an urban forest model. None var None (:obj: string ): a valid memory variable of a tree. None Returns: Type Description ( obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: View Source def get_raster_data ( dtwin , var = 'unique_id' , probe = lambda x , y : x + y , predicate = lambda x : x , init = 0 , counts = False ): \"\"\"A general purpose function that collects celular data on the grid. Args: dtwin: (:obj:`Urban`): an urban forest model. var: (:obj:`string`): a valid memory variable of a tree. Returns: (:obj:numpy.ndarray`): raster like data on a 2D grid. Note: Todo: \"\"\" if counts : probe = lambda x , y : x + 1 raster = np . zeros (( dtwin . grid . width , dtwin . grid . height )) for cell in dtwin . grid . coord_iter (): cell_content , x , y = cell cell_content = filter ( lambda x : x . condition not in [ 'dead' , 'replaced' ], cell_content ) filtered = filter ( predicate , [ eval ( 'a.{}' . format ( var )) for a in cell_content ]) raster [ x ][ y ] = reduce ( probe , filtered , init ) return raster","title":"get_raster_data"},{"location":"reference/src/gus/weather/","text":"Module src.gus.weather None None View Source # -*- coding: utf-8 -*- import numpy as np class WeatherSim (): \"\"\"The environment objects that simulates the weather.\"\"\" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ): \"\"\"The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\"\" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ): \"\"\"The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\"\" return self . frost_free_days_ref Classes WeatherSim class WeatherSim ( season_length = None , season_var = None ) View Source class WeatherSim () : \" \"\" The environment objects that simulates the weather. \"\" \" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ) : \" \"\" The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\" \" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref Class variables ffdays_mean ffdays_var Methods check_frost_free_days def check_frost_free_days ( self ) The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj: int ): Number of frost free days. Note: Todo: View Source def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"Weather"},{"location":"reference/src/gus/weather/#module-srcgusweather","text":"None None View Source # -*- coding: utf-8 -*- import numpy as np class WeatherSim (): \"\"\"The environment objects that simulates the weather.\"\"\" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ): \"\"\"The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\"\" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ): \"\"\"The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\"\" return self . frost_free_days_ref","title":"Module src.gus.weather"},{"location":"reference/src/gus/weather/#classes","text":"","title":"Classes"},{"location":"reference/src/gus/weather/#weathersim","text":"class WeatherSim ( season_length = None , season_var = None ) View Source class WeatherSim () : \" \"\" The environment objects that simulates the weather. \"\" \" # Yearly mean frost free days at a given site. # Source for 153 iTree, Nowak et.al., 2020. ffdays_mean = 153 # Yearly variance in frost free days for a given site. ffdays_var = 7 def __init__ ( self , season_length = None , season_var = None ) : \" \"\" The constructor method. Args: season_length: (:obj:`float`): Mean length of carbon sequestraion season. season_var: (:obj:`float`): variance in year by year change, assuming a stable climate condition. Returns: None Note: * The current model assumes a stable climate condition and draws growth season by site specific mean and varaiance to employ a normal distribution of expectations in the future. Todo: * Update the weather simulation based on trend and climate change. \"\" \" if season_length : self . ffdays_mean = season_length if season_var : self . ffdays_var = season_var # Drawing frost free days for the given year from a normal distriburion # where the mean is based on iTree's proxy variable. self . frost_free_days_ref = np . random . normal ( self . ffdays_mean , self . ffdays_var ) def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"WeatherSim"},{"location":"reference/src/gus/weather/#class-variables","text":"ffdays_mean ffdays_var","title":"Class variables"},{"location":"reference/src/gus/weather/#methods","text":"","title":"Methods"},{"location":"reference/src/gus/weather/#check_frost_free_days","text":"def check_frost_free_days ( self ) The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj: int ): Number of frost free days. Note: Todo: View Source def check_frost_free_days ( self ) : \" \"\" The method generates frost free days based on mean and variance of a given site. Args: None Returns: (:obj:`int`): Number of frost free days. Note: Todo: \"\" \" return self . frost_free_days_ref","title":"check_frost_free_days"},{"location":"reference/src/impacts/","text":"Module src.impacts None None Sub-modules src.impacts.carbon src.impacts.water","title":"Index"},{"location":"reference/src/impacts/#module-srcimpacts","text":"None None","title":"Module src.impacts"},{"location":"reference/src/impacts/#sub-modules","text":"src.impacts.carbon src.impacts.water","title":"Sub-modules"},{"location":"reference/src/impacts/carbon/","text":"Module src.impacts.carbon None None View Source # -*- coding: utf-8 -*- # Carbon storage estimation. from ..gus.allometrics import Species class Carbon (): \"\"\"Species specific biomass and carbon storage estimator.\"\"\" # Unit: Kg, Ref: iTree, 2020 storage_cap = 7500 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 (Chow and Rolfe 1989). coeff = 0.5 def __init__ ( self , allometrics , species_name = None ): \"\"\"Constructor method. Args: allometrics (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: None \"\"\" self . Allometrics = Species ( allometrics ) if species_name : self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \"\"\"The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\"\" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \"\"\"The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\"\" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff Classes Carbon class Carbon ( allometrics , species_name = None ) View Source class Carbon () : \" \"\" Species specific biomass and carbon storage estimator. \"\" \" # Unit: Kg, Ref: iTree, 2020 storage_cap = 7500 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 (Chow and Rolfe 1989). coeff = 0.5 def __init__ ( self , allometrics , species_name = None ) : \" \"\" Constructor method. Args: allometrics (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: None \"\" \" self . Allometrics = Species ( allometrics ) if species_name : self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\" \" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\" \" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff Class variables coeff storage_cap Methods compute_biomass def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float The carbon storage calculation for a tree, in KG. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None dbh None (:obj: float ): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. None height None (:obj: float ): The tree height in meters. None Returns: Type Description ( obj: float ): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. View Source def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\" \" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff compute_carbon_storage def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float The carbon storage calculation for a tree, in KG. Parameters: Name Type Description Default dbh None (:obj: float ): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. None species_name None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None height None (:obj: float ): The tree height in meters. None Returns: Type Description ( obj: float ): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. View Source def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\" \" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage","title":"Carbon"},{"location":"reference/src/impacts/carbon/#module-srcimpactscarbon","text":"None None View Source # -*- coding: utf-8 -*- # Carbon storage estimation. from ..gus.allometrics import Species class Carbon (): \"\"\"Species specific biomass and carbon storage estimator.\"\"\" # Unit: Kg, Ref: iTree, 2020 storage_cap = 7500 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 (Chow and Rolfe 1989). coeff = 0.5 def __init__ ( self , allometrics , species_name = None ): \"\"\"Constructor method. Args: allometrics (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: None \"\"\" self . Allometrics = Species ( allometrics ) if species_name : self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \"\"\"The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\"\" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \"\"\"The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\"\" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff","title":"Module src.impacts.carbon"},{"location":"reference/src/impacts/carbon/#classes","text":"","title":"Classes"},{"location":"reference/src/impacts/carbon/#carbon","text":"class Carbon ( allometrics , species_name = None ) View Source class Carbon () : \" \"\" Species specific biomass and carbon storage estimator. \"\" \" # Unit: Kg, Ref: iTree, 2020 storage_cap = 7500 # The coeff is used to estimate carbon storage through biomass. # The stock of carbon is estimated by multiplying tree biomass by 0.5 (Chow and Rolfe 1989). coeff = 0.5 def __init__ ( self , allometrics , species_name = None ) : \" \"\" Constructor method. Args: allometrics (:obj:`str`): The name of the file that keeps allometrics of the tree species for the site. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch Returns: None \"\" \" self . Allometrics = Species ( allometrics ) if species_name : self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\" \" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\" \" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff","title":"Carbon"},{"location":"reference/src/impacts/carbon/#class-variables","text":"coeff storage_cap","title":"Class variables"},{"location":"reference/src/impacts/carbon/#methods","text":"","title":"Methods"},{"location":"reference/src/impacts/carbon/#compute_biomass","text":"def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float The carbon storage calculation for a tree, in KG. Parameters: Name Type Description Default species_name None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None dbh None (:obj: float ): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. None height None (:obj: float ): The tree height in meters. None Returns: Type Description ( obj: float ): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. View Source def compute_biomass ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Convert and extend this into carbon estimation object. \"\" \" carbon_estimate = self . compute_carbon_storage ( dbh , species_name ) return carbon_estimate / Carbon . coeff","title":"compute_biomass"},{"location":"reference/src/impacts/carbon/#compute_carbon_storage","text":"def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float The carbon storage calculation for a tree, in KG. Parameters: Name Type Description Default dbh None (:obj: float ): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. None species_name None (:obj: string ): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch None height None (:obj: float ): The tree height in meters. None Returns: Type Description ( obj: float ): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. View Source def compute_carbon_storage ( self , dbh , species_name = 'decidu' , height = None ) -> float : \" \"\" The carbon storage calculation for a tree, in KG. Args: dbh: (:obj:`float`): the DBH measure which is diameter in cm of the trunk usually measured at 1.3m from the ground. species_name: (:obj:`string`): name of the species in 'genusName_speciesName' format. Ex: 'picea_abies'. Use the iTree naming scheme: https://database.itreetools.org/#/speciesSearch height: (:obj:`float`): The tree height in meters. Returns: (:obj:`float`): Carbon in Kg. TODO: Update the method to allow receive the height data and use the allometric equations with height parameter. \"\" \" # Load species composition and their allometrics self . species_name = self . Allometrics . fuzzymatching ( species_name ) self . f_biomass = self . Allometrics . get_eqn_biomass ( species_name ) biomass = self . f_biomass ( dbh ) carbon_estimate = biomass * Carbon . coeff # min() function prevents carbon storage from over estimation for very large trees carbon_storage = min ( carbon_estimate , Carbon . storage_cap ) return carbon_storage","title":"compute_carbon_storage"},{"location":"reference/src/impacts/water/","text":"Module src.impacts.water None None View Source # -*- coding: utf-8 -*- # Water retention related implementation. # Based on Notebook implemenation created by Marko Petrovic # Numerical data processing import pandas as pd import numpy as np from scipy import stats # Time series operations import glob from datetime import datetime class Calibration (): \"\"\"Water retention and impact estimate related parameters setting.\"\"\" # Conversion coefficient meter to millimeter m_to_mm = 1 # Extinction coefficient =0.7 for trees and 0.3 for shrubs (Wang et al. 2008) kappa = 0.7 # Shade factor, is the percentage of sky covered by foliage and branches within # the perimeter of individual tree crowns, can vary by species from about # 60% to 95% when trees are in-leaf (McPherson, 1984). # The value below is set according to Glasgow mean avg_shade_factor = 0.85 # Specific leaf storage of water (sl =0.0002 m). leaf_storage = 0.0002 * m_to_mm # Leaf-on leaf_off transition days (Wang_et_al_2008). leaf_transition_days = 28 # Specific impervious cover storage of water (=0.0015 m). maximum_impervious_cover_storage = 0.0015 * m_to_mm # Specific pervious cover storage of water (=0.001 m). maximum_pervious_cover_storage = 0.001 * m_to_mm def __init__ ( self , leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.0010 , impervios_storage_max = 0.0015 ): \"\"\"The constructor method. Args: leaf_transition_days: (:obj:`int`): Leaf-on leaf_off transition days leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: TODO: * pass optional settings as key word parameters. \"\"\" self . leaf_storage = leaf_storage * Calibration . m_to_mm self . leaf_transition_days = leaf_transition_days self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def set_surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ): \"\"\"Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\"\" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = Calibration . avg_shade_factor ): \"\"\"The function given allometrics of a tree computes its leaf, bark and plant area indices. Args: dbh: (:obj:`float`): the diameter in cm of the trunk usually measured at 1.3m from the ground. tree_height: (:obj:`float`): The tree height in meters. crown_height: (:obj:`float`): The vertical length of tree crown in meters. crown_width: (:obj:`float`): The horizontal length (diameter) of tree crown in meters. crown_missing: (:obj:`float`): The percentage loss of the crown. shade_factor: (:obj:`float`): The percentage of sky covered by foliage and branches. Returns: (:obj:`tuple`): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. \"\"\" loss = crown_missing th = tree_height cw = crown_width ch = crown_height sf = shade_factor beta_0 = - 4.3309 beta_1 = 0.2942 beta_2 = 0.7312 beta_3 = 5.7217 beta_4 = 0.0148 def compute_under_canopy_area ( crown_width ): return pow (( crown_width / 2 ), 2 ) * np . pi def compute_bark_area ( dbh , tree_height , crown_height ): # * 0.01 converts DBH(cm) into meter. return np . pi * ( dbh * 0.01 ) * ( tree_height - crown_height ) # Outer surface area estimate below is based on Gacka-Grzesikiewicz (1980). under_canopy = compute_under_canopy_area ( cw ) crown_surface = np . pi * crown_width * ( crown_height + crown_width ) / 2 bark_area = compute_bark_area ( dbh , th , ch ) leaf_area = ( 1 - loss ) * np . exp ( beta_0 + beta_1 * th + beta_2 * cw + beta_3 * sf - beta_4 * crown_surface ) leaf_area_index = leaf_area / under_canopy bark_area_index = bark_area / under_canopy plant_area_index = leaf_area_index + bark_area_index return ( leaf_area_index , bark_area_index , plant_area_index ) def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ): \"\"\"The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Args: A data frame \"x\" with following variables: Date_time: (:obj:`time`): date and time BAI: Bark Area Index LAI: Leaf Area Index conifers: it taks value \"true\" if conifers and \"false\" otherwise leaf_on_start: a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round leaf_off_start: a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). leaf_transition_days: the number of days that the leaf on-off transition last. Returns: An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: \"\"\" x = x . assign ( PAI = np . where ( x [ 'Conifers' ], x [ 'BAI' ] + x [ 'LAI' ], np . where ( x . Date_time . dt . day_of_year < leaf_on_start , x [ 'BAI' ], np . where ((( x . Date_time . dt . day_of_year >= leaf_on_start ) & ( x . Date_time . dt . day_of_year < leaf_off_start )), x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * ( x . Date_time . dt . day_of_year - ( leaf_on_start + leaf_transition_days / 2 )))) + x [ 'BAI' ], x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * (( leaf_off_start + leaf_transition_days / 2 ) - x . Date_time . dt . day_of_year ))) + x [ 'BAI' ]))) ) return x [ 'PAI' ] def lmbd ( temperature ): \"\"\"The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2.501 - 0.002361 * temperature def e_s ( temperature ): \"\"\"The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * temperature / ( 237.3 + temperature )) def e ( dew_point_temperature ): \"\"\"The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * dew_point_temperature / ( 237.3 + dew_point_temperature )) def DELTA ( temperature ): \"\"\"The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 4098 * e_s ( temperature ) / ( 237.3 + temperature ) ** 2 def rho_a ( temperature , surface_pressure ): \"\"\"The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 3.486 * surface_pressure / ( 275 + temperature ) def rho_w ( temperature ): \"\"\"The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 999.88 + 0.018 * temperature - 0.0051 * temperature ** 2 def D ( temperature , dew_point_temperature ): \"\"\"The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return np . maximum ( e_s ( temperature ) - e ( dew_point_temperature ), 0 ) def U_t ( wind_speed , wind_estimate_height ): \"\"\"The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return wind_speed * np . log ( wind_estimate_height / d_w ) / np . log ( Z_u / d_w ) def r_a ( wind_speed , wind_estimate_height , roughness_height ): \"\"\"The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" if roughness_height >= 0 : return 4.72 * np . log ( wind_estimate_height / ( Z_ov * roughness_height )) / ( 1 + 0.53 * U_t ( wind_speed , wind_estimate_height )) else : return 208 / U_t ( wind_speed , wind_estimate_height ) def gamma ( temperature , surface_pressure ): \"\"\"The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" #return 10**(-3)*c_p*surface_pressure*10/(lmbd(temperature)*0.622)# pressure in mbar return 10 ** ( - 3 ) * c_p * surface_pressure / ( lmbd ( temperature ) * 0.622 ) # pressure in kPa def r_s ( pai ): \"\"\"The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 200 / pai def C_leaf ( temperature ): \"\"\"The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e_s ( temperature ) / ( temperature + 273.15 ) def C_air ( dew_point_temperature , temperature ): \"\"\"The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e ( dew_point_temperature ) / ( temperature + 273.15 ) def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ): \"\"\"The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" potential_evaporation = M_TO_MM * ( 1 / ( lmbd ( temperature ) * rho_w ( temperature ))) * ( DELTA ( temperature ) * solar_radiation + ( rho_a ( temperature , sea_level_pressure ) * c_p * D ( temperature , dew_point )) / r_a ( wind_speed , wind_estimate_height , roughness_height )) / ( DELTA ( temperature ) + gamma ( temperature , sea_level_pressure ) * ( 1 + ( r_s ( pai ) / r_a ( wind_speed , wind_estimate_height , roughness_height )))) return potential_evaporation def potential_evapotranspiration ( df ): \"\"\"The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" df = df . assign ( Potential_evaporation_v = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , roughness_height_trees ), Potential_evaporation_g = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , 1 , x . Wind_Speed , 1 , roughness_height_bare_soil ), PET = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , - 1 ), Transpiration = lambda x : 10 ** ( - 6 ) * ( 3600 / x . PAI ) * np . maximum (( C_leaf ( x . Temperature ) - C_air ( x . Dew_Point , x . Temperature )), 0 ) / ( r_s ( x . PAI ) + r_a ( x . Wind_Speed , x . height , roughness_height_trees )) ) df = df . assign ( TF_average_ratio = lambda x : np . where ((( x . PET > x . Transpiration ) & ( x . PET > 0 )), x . Transpiration / x . PET , np . nan ) ) df [ 'TF_average_ratio' ] = df . groupby ([ 'AgentID' , 'Step' ])[ 'TF_average_ratio' ] . transform ( 'mean' ) df = df . assign ( Transpiration = lambda x : np . where ((( x . PAI < ( x . LAI + x . BAI )) | ( x . Transpiration > x . PET )), x . TF_average_ratio * x . PET , x . Transpiration ) ) df = df . drop ( columns = 'TF_average_ratio' ) return df def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ): \"\"\"The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args: Date_time [time identifier] Precipitation [amount of water hitting the surface area of the type] Potential_evaporation [of the type for the given weather conditions] Maximum_storage [parameter: maximum storage of the type] evp [evaporation coefficient for the type] Returns: Precipitation storage of the type for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df = pd . DataFrame ({ 'Date_time' : Date_time , 'Precipitation' : Precipitation , 'Potential_evaporation' : Potential_evaporation }) df [ \"Storage\" ] = 0 df [ 'Potential_evaporation_lag1' ] = df . Potential_evaporation . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x new_value = new_value = np . maximum ( 0 ,( np . minimum ( Maximum_storage , x ) + row [ 'Precipitation' ] - np . minimum ( np . minimum ( Maximum_storage , x ),(( np . minimum ( Maximum_storage , x ) / Maximum_storage ) ** ( evp ) * row [ 'Potential_evaporation_lag1' ])))) x = new_value return new_value # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) return df [ \"Storage\" ] def ped3 ( df , evp_v , evp_g ): \"\"\"The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Args: A data frame including the following variables: Evaporation coefficient for trees: evp_v Evaporation coefficient for ground: evp_g Returns: A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df [ 'Storage' ] = 0 df [ 'Potential_evaporation_v_lag1' ] = df . Potential_evaporation_v . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) df [ 'Potential_evaporation_g_lag1' ] = df . Potential_evaporation_g . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 y = 0 z = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x nonlocal y nonlocal z new_value_x = np . maximum ( 0 ,( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) + row [ 'Canopy_interception' ] - np . minimum ( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ),(( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) / row [ 'Maximum_vegetation_storage' ]) ** ( evp_v ) * row [ 'Potential_evaporation_v_lag1' ])))) Precipitation_on_the_ground_with_vegetation = np . maximum ( 0 ,( new_value_x - row [ 'Maximum_vegetation_storage' ])) + row [ 'Through_canopy_precipitation' ] new_value_y = np . maximum ( 0 ,( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ),(( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) / MAXIMUM_IMPERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) new_value_z = np . maximum ( 0 ,( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ),(( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) / MAXIMUM_PERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) x = new_value_x y = new_value_y z = new_value_z return [ new_value_x , new_value_y , new_value_z ] # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) df [ 'Vegetation_storage' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 0 ] df [ 'Impervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 1 ] df [ 'Pervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 2 ] df = df . drop ( columns = 'Storage' ) return df def ecosystem_services ( i ): \"\"\"The method parallelize the computation of water retention benefits. Args: agent index \"i\" Returns: water retention benefits for each agent [data frame] Note: Todo: \"\"\" output = df_scenario [ tree_population . AgentID == AGENTS [ i ]] output = output [[ 'Step' , 'AgentID' , 'height' , 'BAI' , 'LA' , 'LAI' , 'PAI' , 'Conifers' , 'Under_canopy_area' , 'Total_under_canopy_area' , 'Scenario' , 'Precipitation_scale' , 'SAMPLE_AREA' , 'IMPERVIOUS_COVER_SHARE' , 'PERVIOUS_COVER_SHARE' , 'POPULATION_AREA' , 'POPULATION_SAMPLE_TREE_RATIO' ]] output = pd . merge ( output , weather_forcast , on = [ 'Step' ], how = 'left' ) . sort_values ([ 'Step' , 'AgentID' ]) # Calculate plant area index (PAI) in leaf-on and leaf-off seasons output [ 'PAI' ] = pai_seasons ( output [[ 'Date_time' , 'BAI' , 'LAI' , 'Conifers' ]], Leaf_on_transition_day_start , Leaf_off_transition_day_start , LEAF_TRANSITION_DAYS ) # Calculate potential evapotranspiration over the vegetation and ground areas output = potential_evapotranspiration ( output ) output = output . assign ( Canopy_cover_fraction = lambda x : 1 - np . exp ( - KAPPA * x . PAI ), Maximum_vegetation_storage = lambda x : SL * x . PAI , Through_canopy_precipitation = lambda x : x . Precipitation * ( 1 - x . Canopy_cover_fraction ), Canopy_interception = lambda x : x . Precipitation - x . Through_canopy_precipitation ) output = ped3 ( output , evp_v = 2 / 3 , evp_g = 1 ) output = output . assign ( Canopy_drip = lambda x : np . maximum ( 0 ,( x . Vegetation_storage - x . Maximum_vegetation_storage )), Evaporation_from_vegetation = lambda x : np . maximum ( 0 ,( x . Canopy_interception - x . Canopy_drip )), Precipitation_on_the_ground_with_vegetation = lambda x : x . Canopy_drip + x . Through_canopy_precipitation , Vegetation_storage = lambda x : np . minimum ( x . Vegetation_storage , x . Maximum_vegetation_storage ), Run_off_v = lambda x : np . maximum ( 0 ,( x . Impervious_cover_storage_v - MAXIMUM_IMPERVIOUS_COVER_STORAGE )), Evaporation_from_impervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Run_off_v )), Impervious_cover_storage_v = lambda x : np . minimum ( x . Impervious_cover_storage_v , MAXIMUM_IMPERVIOUS_COVER_STORAGE ), Infiltration_v = lambda x : np . maximum ( 0 ,( x . Pervious_cover_storage_v - MAXIMUM_PERVIOUS_COVER_STORAGE )), Evaporation_from_pervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Infiltration_v )), Pervious_cover_storage_v = lambda x : np . minimum ( x . Pervious_cover_storage_v , MAXIMUM_PERVIOUS_COVER_STORAGE ) ) # Annual aggregation output = output . groupby ([ 'Scenario' , 'Precipitation_scale' , 'AgentID' , 'Step' ]) . agg ( Leaf_area = pd . NamedAgg ( column = 'LA' , aggfunc = np . mean ), Under_canopy_area = pd . NamedAgg ( column = 'Under_canopy_area' , aggfunc = np . mean ), SAMPLE_AREA = pd . NamedAgg ( column = 'SAMPLE_AREA' , aggfunc = np . mean ), IMPERVIOUS_COVER_SHARE = pd . NamedAgg ( column = 'IMPERVIOUS_COVER_SHARE' , aggfunc = np . mean ), PERVIOUS_COVER_SHARE = pd . NamedAgg ( column = 'PERVIOUS_COVER_SHARE' , aggfunc = np . mean ), POPULATION_AREA = pd . NamedAgg ( column = 'POPULATION_AREA' , aggfunc = np . mean ), POPULATION_SAMPLE_TREE_RATIO = pd . NamedAgg ( column = 'POPULATION_SAMPLE_TREE_RATIO' , aggfunc = np . mean ), Annual_precipitation = pd . NamedAgg ( column = 'Precipitation' , aggfunc = np . sum ), Annual_canopy_interception_loss = pd . NamedAgg ( column = 'Evaporation_from_vegetation' , aggfunc = np . sum ), Annual_run_off_v = pd . NamedAgg ( column = 'Run_off_v' , aggfunc = np . sum ), Annual_evaporation_from_impervious_cover_v = pd . NamedAgg ( column = 'Evaporation_from_impervious_cover_v' , aggfunc = np . sum ), Annual_infiltration_v = pd . NamedAgg ( column = \"Infiltration_v\" , aggfunc = np . sum ), Annual_evaporation_from_pervious_cover_v = pd . NamedAgg ( column = \"Evaporation_from_pervious_cover_v\" , aggfunc = np . sum ), Annual_transpiration = pd . NamedAgg ( column = \"Transpiration\" , aggfunc = np . sum ), Total_under_canopy_area = pd . NamedAgg ( column = 'Total_under_canopy_area' , aggfunc = np . mean ), ) . reset_index () output [ 'Annual_stormwater_retention' ] = output . Annual_transpiration + output . Annual_canopy_interception_loss + output . Annual_evaporation_from_impervious_cover_v * output . IMPERVIOUS_COVER_SHARE + output . Annual_evaporation_from_pervious_cover_v * output . PERVIOUS_COVER_SHARE return output Functions C_air def C_air ( dew_point_temperature , temperature ) The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def C_air ( dew_point_temperature , temperature ) : \"\"\"The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e ( dew_point_temperature ) / ( temperature + 273.15 ) C_leaf def C_leaf ( temperature ) The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def C_leaf ( temperature ) : \"\"\"The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e_s ( temperature ) / ( temperature + 273.15 ) D def D ( temperature , dew_point_temperature ) The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def D ( temperature , dew_point_temperature ) : \"\"\"The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return np . maximum ( e_s ( temperature ) - e ( dew_point_temperature ), 0 ) DELTA def DELTA ( temperature ) The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def DELTA ( temperature ) : \"\"\"The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 4098 * e_s ( temperature ) / ( 237.3 + temperature ) ** 2 U_t def U_t ( wind_speed , wind_estimate_height ) The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def U_t ( wind_speed , wind_estimate_height ) : \"\"\"The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return wind_speed * np . log ( wind_estimate_height / d_w ) / np . log ( Z_u / d_w ) compute_leaf_area_index def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = 0.85 ) The function given allometrics of a tree computes its leaf, bark and plant area indices. Parameters: Name Type Description Default dbh None (:obj: float ): the diameter in cm of the trunk usually measured at 1.3m from the ground. None tree_height None (:obj: float ): The tree height in meters. None crown_height None (:obj: float ): The vertical length of tree crown in meters. None crown_width None (:obj: float ): The horizontal length (diameter) of tree crown in meters. None crown_missing None (:obj: float ): The percentage loss of the crown. None shade_factor None (:obj: float ): The percentage of sky covered by foliage and branches. None Returns: Type Description ( obj: tuple ): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. | View Source def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = Calibration . avg_shade_factor ) : \" \"\" The function given allometrics of a tree computes its leaf, bark and plant area indices. Args: dbh: (:obj:`float`): the diameter in cm of the trunk usually measured at 1.3m from the ground. tree_height: (:obj:`float`): The tree height in meters. crown_height: (:obj:`float`): The vertical length of tree crown in meters. crown_width: (:obj:`float`): The horizontal length (diameter) of tree crown in meters. crown_missing: (:obj:`float`): The percentage loss of the crown. shade_factor: (:obj:`float`): The percentage of sky covered by foliage and branches. Returns: (:obj:`tuple`): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. \"\" \" loss = crown_missing th = tree_height cw = crown_width ch = crown_height sf = shade_factor beta_0 = - 4.3309 beta_1 = 0.2942 beta_2 = 0.7312 beta_3 = 5.7217 beta_4 = 0.0148 def compute_under_canopy_area ( crown_width ) : return pow (( crown_width / 2 ), 2 ) * np . pi def compute_bark_area ( dbh , tree_height , crown_height ) : # * 0.01 converts DBH(cm) into meter. return np . pi * ( dbh * 0.01 ) * ( tree_height - crown_height ) # Outer surface area estimate below is based on Gacka-Grzesikiewicz (1980). under_canopy = compute_under_canopy_area ( cw ) crown_surface = np . pi * crown_width * ( crown_height + crown_width ) / 2 bark_area = compute_bark_area ( dbh , th , ch ) leaf_area = ( 1 - loss ) * np . exp ( beta_0 + beta_1 * th + beta_2 * cw + beta_3 * sf - beta_4 * crown_surface ) leaf_area_index = leaf_area / under_canopy bark_area_index = bark_area / under_canopy plant_area_index = leaf_area_index + bark_area_index return ( leaf_area_index , bark_area_index , plant_area_index ) e def e ( dew_point_temperature ) The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def e ( dew_point_temperature ) : \"\"\"The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * dew_point_temperature / ( 237.3 + dew_point_temperature )) e_s def e_s ( temperature ) The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def e_s ( temperature ) : \"\"\"The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * temperature / ( 237.3 + temperature )) ecosystem_services def ecosystem_services ( i ) The method parallelize the computation of water retention benefits. Args: agent index \"i\" Returns: water retention benefits for each agent [data frame] Note: Todo: View Source def ecosystem_services ( i ) : \"\"\"The method parallelize the computation of water retention benefits. Args : agent index \"i\" Returns : water retention benefits for each agent [ data frame ] Note : Todo : \"\"\" output = df_scenario [ tree_population . AgentID == AGENTS [ i ]] output = output [[ ' Step ' , ' AgentID ' , ' height ',' BAI ' , ' LA ',' LAI ' , ' PAI ' , ' Conifers ' , ' Under_canopy_area ' , ' Total_under_canopy_area ',' Scenario ' , ' Precipitation_scale ' , ' SAMPLE_AREA ' , ' IMPERVIOUS_COVER_SHARE ' , ' PERVIOUS_COVER_SHARE ' , ' POPULATION_AREA ' , ' POPULATION_SAMPLE_TREE_RATIO ' ]] output = pd . merge ( output , weather_forcast , on = [ ' Step ' ], how = ' left ' ). sort_values ([ ' Step ' , ' AgentID ' ]) # Calculate plant area index (PAI) in leaf-on and leaf-off seasons output [ ' PAI ' ] = pai_seasons ( output [[ ' Date_time ' , ' BAI ' , ' LAI ' , ' Conifers ' ]], Leaf_on_transition_day_start , Leaf_off_transition_day_start , LEAF_TRANSITION_DAYS ) # Calculate potential evapotranspiration over the vegetation and ground areas output = potential_evapotranspiration ( output ) output = output . assign ( Canopy_cover_fraction = lambda x : 1 - np . exp ( - KAPPA * x . PAI ), Maximum_vegetation_storage = lambda x : SL * x . PAI , Through_canopy_precipitation = lambda x : x . Precipitation * ( 1 - x . Canopy_cover_fraction ), Canopy_interception = lambda x : x . Precipitation - x . Through_canopy_precipitation ) output = ped3 ( output , evp_v = 2 / 3 , evp_g = 1 ) output = output . assign ( Canopy_drip = lambda x : np . maximum ( 0 ,( x . Vegetation_storage - x . Maximum_vegetation_storage )), Evaporation_from_vegetation = lambda x : np . maximum ( 0 ,( x . Canopy_interception - x . Canopy_drip )), Precipitation_on_the_ground_with_vegetation = lambda x : x . Canopy_drip + x . Through_canopy_precipitation , Vegetation_storage = lambda x : np . minimum ( x . Vegetation_storage , x . Maximum_vegetation_storage ), Run_off_v = lambda x : np . maximum ( 0 ,( x . Impervious_cover_storage_v - MAXIMUM_IMPERVIOUS_COVER_STORAGE )), Evaporation_from_impervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Run_off_v )), Impervious_cover_storage_v = lambda x : np . minimum ( x . Impervious_cover_storage_v , MAXIMUM_IMPERVIOUS_COVER_STORAGE ), Infiltration_v = lambda x : np . maximum ( 0 ,( x . Pervious_cover_storage_v - MAXIMUM_PERVIOUS_COVER_STORAGE )), Evaporation_from_pervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Infiltration_v )), Pervious_cover_storage_v = lambda x : np . minimum ( x . Pervious_cover_storage_v , MAXIMUM_PERVIOUS_COVER_STORAGE ) ) # Annual aggregation output = output . groupby ([ ' Scenario ',' Precipitation_scale ',' AgentID ',' Step ' ]). agg ( Leaf_area = pd . NamedAgg ( column = ' LA ' , aggfunc = np . mean ), Under_canopy_area = pd . NamedAgg ( column = ' Under_canopy_area ' , aggfunc = np . mean ), SAMPLE_AREA = pd . NamedAgg ( column = ' SAMPLE_AREA ' , aggfunc = np . mean ), IMPERVIOUS_COVER_SHARE = pd . NamedAgg ( column = ' IMPERVIOUS_COVER_SHARE ' , aggfunc = np . mean ), PERVIOUS_COVER_SHARE = pd . NamedAgg ( column = ' PERVIOUS_COVER_SHARE ' , aggfunc = np . mean ), POPULATION_AREA = pd . NamedAgg ( column = ' POPULATION_AREA ' , aggfunc = np . mean ), POPULATION_SAMPLE_TREE_RATIO = pd . NamedAgg ( column = ' POPULATION_SAMPLE_TREE_RATIO ' , aggfunc = np . mean ), Annual_precipitation = pd . NamedAgg ( column = ' Precipitation ' , aggfunc = np . sum ), Annual_canopy_interception_loss = pd . NamedAgg ( column = ' Evaporation_from_vegetation ' , aggfunc = np . sum ), Annual_run_off_v = pd . NamedAgg ( column = ' Run_off_v ' , aggfunc = np . sum ), Annual_evaporation_from_impervious_cover_v = pd . NamedAgg ( column = ' Evaporation_from_impervious_cover_v ' , aggfunc = np . sum ), Annual_infiltration_v = pd . NamedAgg ( column = \"Infiltration_v\" , aggfunc = np . sum ), Annual_evaporation_from_pervious_cover_v = pd . NamedAgg ( column = \"Evaporation_from_pervious_cover_v\" , aggfunc = np . sum ), Annual_transpiration = pd . NamedAgg ( column = \"Transpiration\" , aggfunc = np . sum ), Total_under_canopy_area = pd . NamedAgg ( column = ' Total_under_canopy_area ' , aggfunc = np . mean ), ). reset_index () output [ ' Annual_stormwater_retention ' ] = output . Annual_transpiration + output . Annual_canopy_interception_loss + output . Annual_evaporation_from_impervious_cover_v * output . IMPERVIOUS_COVER_SHARE + output . Annual_evaporation_from_pervious_cover_v * output . PERVIOUS_COVER_SHARE return output gamma def gamma ( temperature , surface_pressure ) The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def gamma ( temperature , surface_pressure ) : \"\"\"The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" #return 10 ** ( - 3 ) * c_p * surface_pressure * 10 / ( lmbd ( temperature ) * 0.622 ) # pressure in mbar return 10 ** ( - 3 ) * c_p * surface_pressure / ( lmbd ( temperature ) * 0.622 ) # pressure in kPa lmbd def lmbd ( temperature ) The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def lmbd ( temperature ) : \"\"\"The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2.501 - 0.002361 * temperature pai_seasons def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ) The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Parameters: Name Type Description Default A data frame \"x\" with following variables None None Date_time None (:obj: time ): date and time None BAI None Bark Area Index None LAI None Leaf Area Index None conifers None it taks value \"true\" if conifers and \"false\" otherwise None leaf_on_start None a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round None leaf_off_start None a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). None leaf_transition_days None the number of days that the leaf on-off transition last. None Returns: Type Description None An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: | View Source def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ) : \" \"\" The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Args: A data frame \" x \" with following variables: Date_time: (:obj:`time`): date and time BAI: Bark Area Index LAI: Leaf Area Index conifers: it taks value \" true \" if conifers and \" false \" otherwise leaf_on_start: a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round leaf_off_start: a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). leaf_transition_days: the number of days that the leaf on-off transition last. Returns: An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: \"\" \" x = x . assign ( PAI = np . where ( x [ 'Conifers' ] , x [ 'BAI' ] + x [ 'LAI' ] , np . where ( x . Date_time . dt . day_of_year < leaf_on_start , x [ 'BAI' ] , np . where ((( x . Date_time . dt . day_of_year >= leaf_on_start ) & ( x . Date_time . dt . day_of_year < leaf_off_start )), x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * ( x . Date_time . dt . day_of_year - ( leaf_on_start + leaf_transition_days / 2 )))) + x [ 'BAI' ] , x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * (( leaf_off_start + leaf_transition_days / 2 ) - x . Date_time . dt . day_of_year ))) + x [ 'BAI' ] ))) ) return x [ 'PAI' ] ped1 def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ) The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args: Date_time [time identifier] Precipitation [amount of water hitting the surface area of the type] Potential_evaporation [of the type for the given weather conditions] Maximum_storage [parameter: maximum storage of the type] evp [evaporation coefficient for the type] Returns: Precipitation storage of the type for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ) : \"\"\"The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args : Date_time [ time identifier ] Precipitation [ amount of water hitting the surface area of the type ] Potential_evaporation [ of the type for the given weather conditions ] Maximum_storage [ parameter : maximum storage of the type ] evp [ evaporation coefficient for the type ] Returns : Precipitation storage of the type for each hour . Note : The function is built upon the following book : Maidment , David R and others . \u201c Handbook of Hydrology , McGraw - Hil . \u201d Inc ., New York , NY , 1992. And a paper : Hirabayashi , Satoshi . \u201c I - Tree Eco United States County - Based Hydrologic Estimates . \u201d Washington , DC : US Department of Agriculture , Forest Service , 2015. Todo : \"\"\" df = pd . DataFrame ({ ' Date_time ' : Date_time , ' Precipitation ' : Precipitation , ' Potential_evaporation ' : Potential_evaporation }) df [ \"Storage\" ] = 0 df [ ' Potential_evaporation_lag1 ' ] = df . Potential_evaporation . shift ( 1 ). interpolate ( limit_direction = ' backward ' ) x = 0 def func2 ( row ) : # non local variable ==> will use pre_value from the ped function nonlocal x new_value = new_value = np . maximum ( 0 ,( np . minimum ( Maximum_storage , x ) + row [ ' Precipitation ' ] - np . minimum ( np . minimum ( Maximum_storage , x ),(( np . minimum ( Maximum_storage , x ) / Maximum_storage ) ** ( evp ) * row [ ' Potential_evaporation_lag1 ' ])))) x = new_value return new_value # This line might throw a SettingWithCopyWarning warning df . loc [ 0 : , ' Storage ' ] = df . loc [ 0 : , : ]. apply ( func2 , axis = 1 ) return df [ \"Storage\" ] ped3 def ped3 ( df , evp_v , evp_g ) The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Parameters: Name Type Description Default A data frame including the following variables None None Evaporation coefficient for trees None evp_v None Evaporation coefficient for ground None evp_g None Returns: Type Description None A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: | View Source def ped3 ( df , evp_v , evp_g ): \"\"\"The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Args: A data frame including the following variables: Evaporation coefficient for trees: evp_v Evaporation coefficient for ground: evp_g Returns: A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df [ 'Storage' ] = 0 df [ 'Potential_evaporation_v_lag1' ] = df . Potential_evaporation_v . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) df [ 'Potential_evaporation_g_lag1' ] = df . Potential_evaporation_g . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 y = 0 z = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x nonlocal y nonlocal z new_value_x = np . maximum ( 0 ,( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) + row [ 'Canopy_interception' ] - np . minimum ( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ),(( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) / row [ 'Maximum_vegetation_storage' ]) ** ( evp_v ) * row [ 'Potential_evaporation_v_lag1' ])))) Precipitation_on_the_ground_with_vegetation = np . maximum ( 0 ,( new_value_x - row [ 'Maximum_vegetation_storage' ])) + row [ 'Through_canopy_precipitation' ] new_value_y = np . maximum ( 0 ,( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ),(( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) / MAXIMUM_IMPERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) new_value_z = np . maximum ( 0 ,( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ),(( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) / MAXIMUM_PERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) x = new_value_x y = new_value_y z = new_value_z return [ new_value_x , new_value_y , new_value_z ] # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) df [ 'Vegetation_storage' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 0 ] df [ 'Impervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 1 ] df [ 'Pervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 2 ] df = df . drop ( columns = 'Storage' ) return df potential_evaporation def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ) The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: View Source def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ) : \"\" \"The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: \"\" \" potential_evaporation = M_TO_MM*(1/(lmbd(temperature)*rho_w(temperature)))*(DELTA(temperature)*solar_radiation+(rho_a(temperature, sea_level_pressure)*c_p*D(temperature, dew_point))/r_a(wind_speed, wind_estimate_height, roughness_height))/(DELTA(temperature)+gamma(temperature, sea_level_pressure)*(1+(r_s(pai)/r_a(wind_speed, wind_estimate_height, roughness_height)))) return potential_evaporation potential_evapotranspiration def potential_evapotranspiration ( df ) The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: View Source def potential_evapotranspiration ( df ) : \"\"\"The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" df = df . assign ( Potential_evaporation_v = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , roughness_height_trees ), Potential_evaporation_g = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , 1 , x . Wind_Speed , 1 , roughness_height_bare_soil ), PET = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , - 1 ), Transpiration = lambda x: 10 ** ( - 6 ) * ( 3600 / x . PAI ) * np . maximum (( C_leaf ( x . Temperature ) - C_air ( x . Dew_Point , x . Temperature )), 0 ) / ( r_s ( x . PAI ) + r_a ( x . Wind_Speed , x . height , roughness_height_trees )) ) df = df . assign ( TF_average_ratio = lambda x: np . where ((( x . PET > x . Transpiration ) & ( x . PET > 0 )), x . Transpiration / x . PET , np . nan ) ) df [' TF_average_ratio '] = df . groupby ([' AgentID ',' Step '])[' TF_average_ratio ']. transform (' mean ') df = df . assign ( Transpiration = lambda x: np . where ((( x . PAI < ( x . LAI + x . BAI )) | ( x . Transpiration > x . PET )), x . TF_average_ratio * x . PET , x . Transpiration ) ) df = df . drop ( columns = ' TF_average_ratio ') return df r_a def r_a ( wind_speed , wind_estimate_height , roughness_height ) The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def r_a ( wind_speed , wind_estimate_height , roughness_height ) : \"\"\"The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" if roughness_height >= 0 : return 4.72 * np . log ( wind_estimate_height / ( Z_ov * roughness_height )) / ( 1 + 0.53 * U_t ( wind_speed , wind_estimate_height )) else : return 208 / U_t ( wind_speed , wind_estimate_height ) r_s def r_s ( pai ) The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def r_s ( pai ) : \"\" \"The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\" \" return 200/pai rho_a def rho_a ( temperature , surface_pressure ) The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def rho_a ( temperature , surface_pressure ) : \"\"\"The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 3.486 * surface_pressure / ( 275 + temperature ) rho_w def rho_w ( temperature ) The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def rho_w ( temperature ) : \"\"\"The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 999.88 + 0.018 * temperature - 0.0051 * temperature ** 2 Classes Calibration class Calibration ( leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.001 , impervios_storage_max = 0.0015 ) View Source class Calibration () : \" \"\" Water retention and impact estimate related parameters setting. \"\" \" # Conversion coefficient meter to millimeter m_to_mm = 1 # Extinction coefficient =0.7 for trees and 0.3 for shrubs (Wang et al. 2008) kappa = 0.7 # Shade factor, is the percentage of sky covered by foliage and branches within # the perimeter of individual tree crowns, can vary by species from about # 60% to 95% when trees are in-leaf (McPherson, 1984). # The value below is set according to Glasgow mean avg_shade_factor = 0.85 # Specific leaf storage of water (sl =0.0002 m). leaf_storage = 0.0002 * m_to_mm # Leaf-on leaf_off transition days (Wang_et_al_2008). leaf_transition_days = 28 # Specific impervious cover storage of water (=0.0015 m). maximum_impervious_cover_storage = 0.0015 * m_to_mm # Specific pervious cover storage of water (=0.001 m). maximum_pervious_cover_storage = 0.001 * m_to_mm def __init__ ( self , leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.0010 , impervios_storage_max = 0.0015 ) : \" \"\" The constructor method. Args: leaf_transition_days: (:obj:`int`): Leaf-on leaf_off transition days leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: TODO: * pass optional settings as key word parameters. \"\" \" self . leaf_storage = leaf_storage * Calibration . m_to_mm self . leaf_transition_days = leaf_transition_days self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def set _surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) : \" \"\" Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\" \" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm Class variables avg_shade_factor kappa leaf_storage leaf_transition_days m_to_mm maximum_impervious_cover_storage maximum_pervious_cover_storage Methods set_surface_storage_rates def set_surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) Setting specific water storage rates. Parameters: Name Type Description Default leaf_storage None (:obj: float ): Specific leaf storage of water. None pervios_storage_max None (:obj: float ): Specific pervious cover storage of water None impervios_storage_max None (:obj: float ): Specific impervious cover storage of water None Returns: Type Description None None Note: Todo: | View Source def set _surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) : \" \"\" Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\" \" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm","title":"Water"},{"location":"reference/src/impacts/water/#module-srcimpactswater","text":"None None View Source # -*- coding: utf-8 -*- # Water retention related implementation. # Based on Notebook implemenation created by Marko Petrovic # Numerical data processing import pandas as pd import numpy as np from scipy import stats # Time series operations import glob from datetime import datetime class Calibration (): \"\"\"Water retention and impact estimate related parameters setting.\"\"\" # Conversion coefficient meter to millimeter m_to_mm = 1 # Extinction coefficient =0.7 for trees and 0.3 for shrubs (Wang et al. 2008) kappa = 0.7 # Shade factor, is the percentage of sky covered by foliage and branches within # the perimeter of individual tree crowns, can vary by species from about # 60% to 95% when trees are in-leaf (McPherson, 1984). # The value below is set according to Glasgow mean avg_shade_factor = 0.85 # Specific leaf storage of water (sl =0.0002 m). leaf_storage = 0.0002 * m_to_mm # Leaf-on leaf_off transition days (Wang_et_al_2008). leaf_transition_days = 28 # Specific impervious cover storage of water (=0.0015 m). maximum_impervious_cover_storage = 0.0015 * m_to_mm # Specific pervious cover storage of water (=0.001 m). maximum_pervious_cover_storage = 0.001 * m_to_mm def __init__ ( self , leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.0010 , impervios_storage_max = 0.0015 ): \"\"\"The constructor method. Args: leaf_transition_days: (:obj:`int`): Leaf-on leaf_off transition days leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: TODO: * pass optional settings as key word parameters. \"\"\" self . leaf_storage = leaf_storage * Calibration . m_to_mm self . leaf_transition_days = leaf_transition_days self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def set_surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ): \"\"\"Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\"\" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = Calibration . avg_shade_factor ): \"\"\"The function given allometrics of a tree computes its leaf, bark and plant area indices. Args: dbh: (:obj:`float`): the diameter in cm of the trunk usually measured at 1.3m from the ground. tree_height: (:obj:`float`): The tree height in meters. crown_height: (:obj:`float`): The vertical length of tree crown in meters. crown_width: (:obj:`float`): The horizontal length (diameter) of tree crown in meters. crown_missing: (:obj:`float`): The percentage loss of the crown. shade_factor: (:obj:`float`): The percentage of sky covered by foliage and branches. Returns: (:obj:`tuple`): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. \"\"\" loss = crown_missing th = tree_height cw = crown_width ch = crown_height sf = shade_factor beta_0 = - 4.3309 beta_1 = 0.2942 beta_2 = 0.7312 beta_3 = 5.7217 beta_4 = 0.0148 def compute_under_canopy_area ( crown_width ): return pow (( crown_width / 2 ), 2 ) * np . pi def compute_bark_area ( dbh , tree_height , crown_height ): # * 0.01 converts DBH(cm) into meter. return np . pi * ( dbh * 0.01 ) * ( tree_height - crown_height ) # Outer surface area estimate below is based on Gacka-Grzesikiewicz (1980). under_canopy = compute_under_canopy_area ( cw ) crown_surface = np . pi * crown_width * ( crown_height + crown_width ) / 2 bark_area = compute_bark_area ( dbh , th , ch ) leaf_area = ( 1 - loss ) * np . exp ( beta_0 + beta_1 * th + beta_2 * cw + beta_3 * sf - beta_4 * crown_surface ) leaf_area_index = leaf_area / under_canopy bark_area_index = bark_area / under_canopy plant_area_index = leaf_area_index + bark_area_index return ( leaf_area_index , bark_area_index , plant_area_index ) def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ): \"\"\"The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Args: A data frame \"x\" with following variables: Date_time: (:obj:`time`): date and time BAI: Bark Area Index LAI: Leaf Area Index conifers: it taks value \"true\" if conifers and \"false\" otherwise leaf_on_start: a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round leaf_off_start: a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). leaf_transition_days: the number of days that the leaf on-off transition last. Returns: An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: \"\"\" x = x . assign ( PAI = np . where ( x [ 'Conifers' ], x [ 'BAI' ] + x [ 'LAI' ], np . where ( x . Date_time . dt . day_of_year < leaf_on_start , x [ 'BAI' ], np . where ((( x . Date_time . dt . day_of_year >= leaf_on_start ) & ( x . Date_time . dt . day_of_year < leaf_off_start )), x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * ( x . Date_time . dt . day_of_year - ( leaf_on_start + leaf_transition_days / 2 )))) + x [ 'BAI' ], x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * (( leaf_off_start + leaf_transition_days / 2 ) - x . Date_time . dt . day_of_year ))) + x [ 'BAI' ]))) ) return x [ 'PAI' ] def lmbd ( temperature ): \"\"\"The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2.501 - 0.002361 * temperature def e_s ( temperature ): \"\"\"The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * temperature / ( 237.3 + temperature )) def e ( dew_point_temperature ): \"\"\"The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * dew_point_temperature / ( 237.3 + dew_point_temperature )) def DELTA ( temperature ): \"\"\"The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 4098 * e_s ( temperature ) / ( 237.3 + temperature ) ** 2 def rho_a ( temperature , surface_pressure ): \"\"\"The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 3.486 * surface_pressure / ( 275 + temperature ) def rho_w ( temperature ): \"\"\"The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 999.88 + 0.018 * temperature - 0.0051 * temperature ** 2 def D ( temperature , dew_point_temperature ): \"\"\"The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return np . maximum ( e_s ( temperature ) - e ( dew_point_temperature ), 0 ) def U_t ( wind_speed , wind_estimate_height ): \"\"\"The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return wind_speed * np . log ( wind_estimate_height / d_w ) / np . log ( Z_u / d_w ) def r_a ( wind_speed , wind_estimate_height , roughness_height ): \"\"\"The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" if roughness_height >= 0 : return 4.72 * np . log ( wind_estimate_height / ( Z_ov * roughness_height )) / ( 1 + 0.53 * U_t ( wind_speed , wind_estimate_height )) else : return 208 / U_t ( wind_speed , wind_estimate_height ) def gamma ( temperature , surface_pressure ): \"\"\"The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" #return 10**(-3)*c_p*surface_pressure*10/(lmbd(temperature)*0.622)# pressure in mbar return 10 ** ( - 3 ) * c_p * surface_pressure / ( lmbd ( temperature ) * 0.622 ) # pressure in kPa def r_s ( pai ): \"\"\"The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 200 / pai def C_leaf ( temperature ): \"\"\"The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e_s ( temperature ) / ( temperature + 273.15 ) def C_air ( dew_point_temperature , temperature ): \"\"\"The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e ( dew_point_temperature ) / ( temperature + 273.15 ) def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ): \"\"\"The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" potential_evaporation = M_TO_MM * ( 1 / ( lmbd ( temperature ) * rho_w ( temperature ))) * ( DELTA ( temperature ) * solar_radiation + ( rho_a ( temperature , sea_level_pressure ) * c_p * D ( temperature , dew_point )) / r_a ( wind_speed , wind_estimate_height , roughness_height )) / ( DELTA ( temperature ) + gamma ( temperature , sea_level_pressure ) * ( 1 + ( r_s ( pai ) / r_a ( wind_speed , wind_estimate_height , roughness_height )))) return potential_evaporation def potential_evapotranspiration ( df ): \"\"\"The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" df = df . assign ( Potential_evaporation_v = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , roughness_height_trees ), Potential_evaporation_g = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , 1 , x . Wind_Speed , 1 , roughness_height_bare_soil ), PET = lambda x : potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , - 1 ), Transpiration = lambda x : 10 ** ( - 6 ) * ( 3600 / x . PAI ) * np . maximum (( C_leaf ( x . Temperature ) - C_air ( x . Dew_Point , x . Temperature )), 0 ) / ( r_s ( x . PAI ) + r_a ( x . Wind_Speed , x . height , roughness_height_trees )) ) df = df . assign ( TF_average_ratio = lambda x : np . where ((( x . PET > x . Transpiration ) & ( x . PET > 0 )), x . Transpiration / x . PET , np . nan ) ) df [ 'TF_average_ratio' ] = df . groupby ([ 'AgentID' , 'Step' ])[ 'TF_average_ratio' ] . transform ( 'mean' ) df = df . assign ( Transpiration = lambda x : np . where ((( x . PAI < ( x . LAI + x . BAI )) | ( x . Transpiration > x . PET )), x . TF_average_ratio * x . PET , x . Transpiration ) ) df = df . drop ( columns = 'TF_average_ratio' ) return df def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ): \"\"\"The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args: Date_time [time identifier] Precipitation [amount of water hitting the surface area of the type] Potential_evaporation [of the type for the given weather conditions] Maximum_storage [parameter: maximum storage of the type] evp [evaporation coefficient for the type] Returns: Precipitation storage of the type for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df = pd . DataFrame ({ 'Date_time' : Date_time , 'Precipitation' : Precipitation , 'Potential_evaporation' : Potential_evaporation }) df [ \"Storage\" ] = 0 df [ 'Potential_evaporation_lag1' ] = df . Potential_evaporation . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x new_value = new_value = np . maximum ( 0 ,( np . minimum ( Maximum_storage , x ) + row [ 'Precipitation' ] - np . minimum ( np . minimum ( Maximum_storage , x ),(( np . minimum ( Maximum_storage , x ) / Maximum_storage ) ** ( evp ) * row [ 'Potential_evaporation_lag1' ])))) x = new_value return new_value # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) return df [ \"Storage\" ] def ped3 ( df , evp_v , evp_g ): \"\"\"The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Args: A data frame including the following variables: Evaporation coefficient for trees: evp_v Evaporation coefficient for ground: evp_g Returns: A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df [ 'Storage' ] = 0 df [ 'Potential_evaporation_v_lag1' ] = df . Potential_evaporation_v . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) df [ 'Potential_evaporation_g_lag1' ] = df . Potential_evaporation_g . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 y = 0 z = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x nonlocal y nonlocal z new_value_x = np . maximum ( 0 ,( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) + row [ 'Canopy_interception' ] - np . minimum ( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ),(( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) / row [ 'Maximum_vegetation_storage' ]) ** ( evp_v ) * row [ 'Potential_evaporation_v_lag1' ])))) Precipitation_on_the_ground_with_vegetation = np . maximum ( 0 ,( new_value_x - row [ 'Maximum_vegetation_storage' ])) + row [ 'Through_canopy_precipitation' ] new_value_y = np . maximum ( 0 ,( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ),(( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) / MAXIMUM_IMPERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) new_value_z = np . maximum ( 0 ,( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ),(( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) / MAXIMUM_PERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) x = new_value_x y = new_value_y z = new_value_z return [ new_value_x , new_value_y , new_value_z ] # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) df [ 'Vegetation_storage' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 0 ] df [ 'Impervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 1 ] df [ 'Pervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 2 ] df = df . drop ( columns = 'Storage' ) return df def ecosystem_services ( i ): \"\"\"The method parallelize the computation of water retention benefits. Args: agent index \"i\" Returns: water retention benefits for each agent [data frame] Note: Todo: \"\"\" output = df_scenario [ tree_population . AgentID == AGENTS [ i ]] output = output [[ 'Step' , 'AgentID' , 'height' , 'BAI' , 'LA' , 'LAI' , 'PAI' , 'Conifers' , 'Under_canopy_area' , 'Total_under_canopy_area' , 'Scenario' , 'Precipitation_scale' , 'SAMPLE_AREA' , 'IMPERVIOUS_COVER_SHARE' , 'PERVIOUS_COVER_SHARE' , 'POPULATION_AREA' , 'POPULATION_SAMPLE_TREE_RATIO' ]] output = pd . merge ( output , weather_forcast , on = [ 'Step' ], how = 'left' ) . sort_values ([ 'Step' , 'AgentID' ]) # Calculate plant area index (PAI) in leaf-on and leaf-off seasons output [ 'PAI' ] = pai_seasons ( output [[ 'Date_time' , 'BAI' , 'LAI' , 'Conifers' ]], Leaf_on_transition_day_start , Leaf_off_transition_day_start , LEAF_TRANSITION_DAYS ) # Calculate potential evapotranspiration over the vegetation and ground areas output = potential_evapotranspiration ( output ) output = output . assign ( Canopy_cover_fraction = lambda x : 1 - np . exp ( - KAPPA * x . PAI ), Maximum_vegetation_storage = lambda x : SL * x . PAI , Through_canopy_precipitation = lambda x : x . Precipitation * ( 1 - x . Canopy_cover_fraction ), Canopy_interception = lambda x : x . Precipitation - x . Through_canopy_precipitation ) output = ped3 ( output , evp_v = 2 / 3 , evp_g = 1 ) output = output . assign ( Canopy_drip = lambda x : np . maximum ( 0 ,( x . Vegetation_storage - x . Maximum_vegetation_storage )), Evaporation_from_vegetation = lambda x : np . maximum ( 0 ,( x . Canopy_interception - x . Canopy_drip )), Precipitation_on_the_ground_with_vegetation = lambda x : x . Canopy_drip + x . Through_canopy_precipitation , Vegetation_storage = lambda x : np . minimum ( x . Vegetation_storage , x . Maximum_vegetation_storage ), Run_off_v = lambda x : np . maximum ( 0 ,( x . Impervious_cover_storage_v - MAXIMUM_IMPERVIOUS_COVER_STORAGE )), Evaporation_from_impervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Run_off_v )), Impervious_cover_storage_v = lambda x : np . minimum ( x . Impervious_cover_storage_v , MAXIMUM_IMPERVIOUS_COVER_STORAGE ), Infiltration_v = lambda x : np . maximum ( 0 ,( x . Pervious_cover_storage_v - MAXIMUM_PERVIOUS_COVER_STORAGE )), Evaporation_from_pervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Infiltration_v )), Pervious_cover_storage_v = lambda x : np . minimum ( x . Pervious_cover_storage_v , MAXIMUM_PERVIOUS_COVER_STORAGE ) ) # Annual aggregation output = output . groupby ([ 'Scenario' , 'Precipitation_scale' , 'AgentID' , 'Step' ]) . agg ( Leaf_area = pd . NamedAgg ( column = 'LA' , aggfunc = np . mean ), Under_canopy_area = pd . NamedAgg ( column = 'Under_canopy_area' , aggfunc = np . mean ), SAMPLE_AREA = pd . NamedAgg ( column = 'SAMPLE_AREA' , aggfunc = np . mean ), IMPERVIOUS_COVER_SHARE = pd . NamedAgg ( column = 'IMPERVIOUS_COVER_SHARE' , aggfunc = np . mean ), PERVIOUS_COVER_SHARE = pd . NamedAgg ( column = 'PERVIOUS_COVER_SHARE' , aggfunc = np . mean ), POPULATION_AREA = pd . NamedAgg ( column = 'POPULATION_AREA' , aggfunc = np . mean ), POPULATION_SAMPLE_TREE_RATIO = pd . NamedAgg ( column = 'POPULATION_SAMPLE_TREE_RATIO' , aggfunc = np . mean ), Annual_precipitation = pd . NamedAgg ( column = 'Precipitation' , aggfunc = np . sum ), Annual_canopy_interception_loss = pd . NamedAgg ( column = 'Evaporation_from_vegetation' , aggfunc = np . sum ), Annual_run_off_v = pd . NamedAgg ( column = 'Run_off_v' , aggfunc = np . sum ), Annual_evaporation_from_impervious_cover_v = pd . NamedAgg ( column = 'Evaporation_from_impervious_cover_v' , aggfunc = np . sum ), Annual_infiltration_v = pd . NamedAgg ( column = \"Infiltration_v\" , aggfunc = np . sum ), Annual_evaporation_from_pervious_cover_v = pd . NamedAgg ( column = \"Evaporation_from_pervious_cover_v\" , aggfunc = np . sum ), Annual_transpiration = pd . NamedAgg ( column = \"Transpiration\" , aggfunc = np . sum ), Total_under_canopy_area = pd . NamedAgg ( column = 'Total_under_canopy_area' , aggfunc = np . mean ), ) . reset_index () output [ 'Annual_stormwater_retention' ] = output . Annual_transpiration + output . Annual_canopy_interception_loss + output . Annual_evaporation_from_impervious_cover_v * output . IMPERVIOUS_COVER_SHARE + output . Annual_evaporation_from_pervious_cover_v * output . PERVIOUS_COVER_SHARE return output","title":"Module src.impacts.water"},{"location":"reference/src/impacts/water/#functions","text":"","title":"Functions"},{"location":"reference/src/impacts/water/#c_air","text":"def C_air ( dew_point_temperature , temperature ) The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def C_air ( dew_point_temperature , temperature ) : \"\"\"The method calculates water vapor concentration in the air. Args: Temperature [C] Dew point temperature [C] Returns: Water vapor concentration in the air in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes vapor pressure e() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e ( dew_point_temperature ) / ( temperature + 273.15 )","title":"C_air"},{"location":"reference/src/impacts/water/#c_leaf","text":"def C_leaf ( temperature ) The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def C_leaf ( temperature ) : \"\"\"The method calculates water vapor concentration at the evaporating surfaces within the leaf. Args: Temperature [C] Returns: Water vapor concentration at the evaporating surfaces within the leaf in [g/m^3] Note: Temerature in celsius [C] is converted to kelvins [K] such that T(K) = T(C)+273.15. The formula also includes saturated vapor pressure e_s() in [kPa]. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2165 * e_s ( temperature ) / ( temperature + 273.15 )","title":"C_leaf"},{"location":"reference/src/impacts/water/#d","text":"def D ( temperature , dew_point_temperature ) The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def D ( temperature , dew_point_temperature ) : \"\"\"The method calculates vapor pressure deficit. Args: Temperature in [C] Dew point temperature in [C] Returns: Vapor pressure deficit in [kPa] Note: It includes in calculation vapor pressure as well as saturated vapor pressure, both in [kPa], which are calculated with functions e() e_s(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return np . maximum ( e_s ( temperature ) - e ( dew_point_temperature ), 0 )","title":"D"},{"location":"reference/src/impacts/water/#delta","text":"def DELTA ( temperature ) The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def DELTA ( temperature ) : \"\"\"The method calculates the slope of vapor pressure temperature curve. Args: Temperature in [C] Returns: Slope of vapor pressure temperature curve in [kPa/C] Note: It includes in calculation saturated vapor pressure in [kPa] which is calculated with function e_s()! The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 4098 * e_s ( temperature ) / ( 237.3 + temperature ) ** 2","title":"DELTA"},{"location":"reference/src/impacts/water/#u_t","text":"def U_t ( wind_speed , wind_estimate_height ) The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def U_t ( wind_speed , wind_estimate_height ) : \"\"\"The method estimates wind speed at the tree top. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Returns: Wind speed at the tree top in [m/s] Note: The method is using two other parameters: Wind measurement height Z_u (usually 10m) and roughness height for water d_w which are set as constants. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return wind_speed * np . log ( wind_estimate_height / d_w ) / np . log ( Z_u / d_w )","title":"U_t"},{"location":"reference/src/impacts/water/#compute_leaf_area_index","text":"def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = 0.85 ) The function given allometrics of a tree computes its leaf, bark and plant area indices. Parameters: Name Type Description Default dbh None (:obj: float ): the diameter in cm of the trunk usually measured at 1.3m from the ground. None tree_height None (:obj: float ): The tree height in meters. None crown_height None (:obj: float ): The vertical length of tree crown in meters. None crown_width None (:obj: float ): The horizontal length (diameter) of tree crown in meters. None crown_missing None (:obj: float ): The percentage loss of the crown. None shade_factor None (:obj: float ): The percentage of sky covered by foliage and branches. None Returns: Type Description ( obj: tuple ): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. | View Source def compute_leaf_area_index ( dbh , tree_height , crown_height , crown_width , crown_missing = 0 , shade_factor = Calibration . avg_shade_factor ) : \" \"\" The function given allometrics of a tree computes its leaf, bark and plant area indices. Args: dbh: (:obj:`float`): the diameter in cm of the trunk usually measured at 1.3m from the ground. tree_height: (:obj:`float`): The tree height in meters. crown_height: (:obj:`float`): The vertical length of tree crown in meters. crown_width: (:obj:`float`): The horizontal length (diameter) of tree crown in meters. crown_missing: (:obj:`float`): The percentage loss of the crown. shade_factor: (:obj:`float`): The percentage of sky covered by foliage and branches. Returns: (:obj:`tuple`): the tuple returns the tree indices (LAI,BAI,PAI) Note: The beta multipliers and the main equation is based on Nowak (1996). TODO: Parametrize beta multipliers. \"\" \" loss = crown_missing th = tree_height cw = crown_width ch = crown_height sf = shade_factor beta_0 = - 4.3309 beta_1 = 0.2942 beta_2 = 0.7312 beta_3 = 5.7217 beta_4 = 0.0148 def compute_under_canopy_area ( crown_width ) : return pow (( crown_width / 2 ), 2 ) * np . pi def compute_bark_area ( dbh , tree_height , crown_height ) : # * 0.01 converts DBH(cm) into meter. return np . pi * ( dbh * 0.01 ) * ( tree_height - crown_height ) # Outer surface area estimate below is based on Gacka-Grzesikiewicz (1980). under_canopy = compute_under_canopy_area ( cw ) crown_surface = np . pi * crown_width * ( crown_height + crown_width ) / 2 bark_area = compute_bark_area ( dbh , th , ch ) leaf_area = ( 1 - loss ) * np . exp ( beta_0 + beta_1 * th + beta_2 * cw + beta_3 * sf - beta_4 * crown_surface ) leaf_area_index = leaf_area / under_canopy bark_area_index = bark_area / under_canopy plant_area_index = leaf_area_index + bark_area_index return ( leaf_area_index , bark_area_index , plant_area_index )","title":"compute_leaf_area_index"},{"location":"reference/src/impacts/water/#e","text":"def e ( dew_point_temperature ) The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def e ( dew_point_temperature ) : \"\"\"The method calculates vapor pressure. Args: Dew point temperature in [C] Returns: Vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * dew_point_temperature / ( 237.3 + dew_point_temperature ))","title":"e"},{"location":"reference/src/impacts/water/#e_s","text":"def e_s ( temperature ) The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def e_s ( temperature ) : \"\"\"The method calculates saturated vapor pressure. Args: Temperature in [C] Returns: Saturated vapor pressure in [kPa] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 0.6108 * np . exp ( 17.27 * temperature / ( 237.3 + temperature ))","title":"e_s"},{"location":"reference/src/impacts/water/#ecosystem_services","text":"def ecosystem_services ( i ) The method parallelize the computation of water retention benefits. Args: agent index \"i\" Returns: water retention benefits for each agent [data frame] Note: Todo: View Source def ecosystem_services ( i ) : \"\"\"The method parallelize the computation of water retention benefits. Args : agent index \"i\" Returns : water retention benefits for each agent [ data frame ] Note : Todo : \"\"\" output = df_scenario [ tree_population . AgentID == AGENTS [ i ]] output = output [[ ' Step ' , ' AgentID ' , ' height ',' BAI ' , ' LA ',' LAI ' , ' PAI ' , ' Conifers ' , ' Under_canopy_area ' , ' Total_under_canopy_area ',' Scenario ' , ' Precipitation_scale ' , ' SAMPLE_AREA ' , ' IMPERVIOUS_COVER_SHARE ' , ' PERVIOUS_COVER_SHARE ' , ' POPULATION_AREA ' , ' POPULATION_SAMPLE_TREE_RATIO ' ]] output = pd . merge ( output , weather_forcast , on = [ ' Step ' ], how = ' left ' ). sort_values ([ ' Step ' , ' AgentID ' ]) # Calculate plant area index (PAI) in leaf-on and leaf-off seasons output [ ' PAI ' ] = pai_seasons ( output [[ ' Date_time ' , ' BAI ' , ' LAI ' , ' Conifers ' ]], Leaf_on_transition_day_start , Leaf_off_transition_day_start , LEAF_TRANSITION_DAYS ) # Calculate potential evapotranspiration over the vegetation and ground areas output = potential_evapotranspiration ( output ) output = output . assign ( Canopy_cover_fraction = lambda x : 1 - np . exp ( - KAPPA * x . PAI ), Maximum_vegetation_storage = lambda x : SL * x . PAI , Through_canopy_precipitation = lambda x : x . Precipitation * ( 1 - x . Canopy_cover_fraction ), Canopy_interception = lambda x : x . Precipitation - x . Through_canopy_precipitation ) output = ped3 ( output , evp_v = 2 / 3 , evp_g = 1 ) output = output . assign ( Canopy_drip = lambda x : np . maximum ( 0 ,( x . Vegetation_storage - x . Maximum_vegetation_storage )), Evaporation_from_vegetation = lambda x : np . maximum ( 0 ,( x . Canopy_interception - x . Canopy_drip )), Precipitation_on_the_ground_with_vegetation = lambda x : x . Canopy_drip + x . Through_canopy_precipitation , Vegetation_storage = lambda x : np . minimum ( x . Vegetation_storage , x . Maximum_vegetation_storage ), Run_off_v = lambda x : np . maximum ( 0 ,( x . Impervious_cover_storage_v - MAXIMUM_IMPERVIOUS_COVER_STORAGE )), Evaporation_from_impervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Run_off_v )), Impervious_cover_storage_v = lambda x : np . minimum ( x . Impervious_cover_storage_v , MAXIMUM_IMPERVIOUS_COVER_STORAGE ), Infiltration_v = lambda x : np . maximum ( 0 ,( x . Pervious_cover_storage_v - MAXIMUM_PERVIOUS_COVER_STORAGE )), Evaporation_from_pervious_cover_v = lambda x : np . maximum ( 0 ,( x . Precipitation_on_the_ground_with_vegetation - x . Infiltration_v )), Pervious_cover_storage_v = lambda x : np . minimum ( x . Pervious_cover_storage_v , MAXIMUM_PERVIOUS_COVER_STORAGE ) ) # Annual aggregation output = output . groupby ([ ' Scenario ',' Precipitation_scale ',' AgentID ',' Step ' ]). agg ( Leaf_area = pd . NamedAgg ( column = ' LA ' , aggfunc = np . mean ), Under_canopy_area = pd . NamedAgg ( column = ' Under_canopy_area ' , aggfunc = np . mean ), SAMPLE_AREA = pd . NamedAgg ( column = ' SAMPLE_AREA ' , aggfunc = np . mean ), IMPERVIOUS_COVER_SHARE = pd . NamedAgg ( column = ' IMPERVIOUS_COVER_SHARE ' , aggfunc = np . mean ), PERVIOUS_COVER_SHARE = pd . NamedAgg ( column = ' PERVIOUS_COVER_SHARE ' , aggfunc = np . mean ), POPULATION_AREA = pd . NamedAgg ( column = ' POPULATION_AREA ' , aggfunc = np . mean ), POPULATION_SAMPLE_TREE_RATIO = pd . NamedAgg ( column = ' POPULATION_SAMPLE_TREE_RATIO ' , aggfunc = np . mean ), Annual_precipitation = pd . NamedAgg ( column = ' Precipitation ' , aggfunc = np . sum ), Annual_canopy_interception_loss = pd . NamedAgg ( column = ' Evaporation_from_vegetation ' , aggfunc = np . sum ), Annual_run_off_v = pd . NamedAgg ( column = ' Run_off_v ' , aggfunc = np . sum ), Annual_evaporation_from_impervious_cover_v = pd . NamedAgg ( column = ' Evaporation_from_impervious_cover_v ' , aggfunc = np . sum ), Annual_infiltration_v = pd . NamedAgg ( column = \"Infiltration_v\" , aggfunc = np . sum ), Annual_evaporation_from_pervious_cover_v = pd . NamedAgg ( column = \"Evaporation_from_pervious_cover_v\" , aggfunc = np . sum ), Annual_transpiration = pd . NamedAgg ( column = \"Transpiration\" , aggfunc = np . sum ), Total_under_canopy_area = pd . NamedAgg ( column = ' Total_under_canopy_area ' , aggfunc = np . mean ), ). reset_index () output [ ' Annual_stormwater_retention ' ] = output . Annual_transpiration + output . Annual_canopy_interception_loss + output . Annual_evaporation_from_impervious_cover_v * output . IMPERVIOUS_COVER_SHARE + output . Annual_evaporation_from_pervious_cover_v * output . PERVIOUS_COVER_SHARE return output","title":"ecosystem_services"},{"location":"reference/src/impacts/water/#gamma","text":"def gamma ( temperature , surface_pressure ) The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def gamma ( temperature , surface_pressure ) : \"\"\"The method calculates psychrometric constant. Args: Temperature [C] Surface pressure [kPa] Returns: Psychrometric constant in [kPA/C] Note: It includes in calculation latent heat of vaporization lmbd(). The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" #return 10 ** ( - 3 ) * c_p * surface_pressure * 10 / ( lmbd ( temperature ) * 0.622 ) # pressure in mbar return 10 ** ( - 3 ) * c_p * surface_pressure / ( lmbd ( temperature ) * 0.622 ) # pressure in kPa","title":"gamma"},{"location":"reference/src/impacts/water/#lmbd","text":"def lmbd ( temperature ) The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def lmbd ( temperature ) : \"\"\"The method calculates latent heat of vaporization. Args: Temperature in [C] Returns: latent heat of vaporization in [MJ/Kg] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 2.501 - 0.002361 * temperature","title":"lmbd"},{"location":"reference/src/impacts/water/#pai_seasons","text":"def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ) The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Parameters: Name Type Description Default A data frame \"x\" with following variables None None Date_time None (:obj: time ): date and time None BAI None Bark Area Index None LAI None Leaf Area Index None conifers None it taks value \"true\" if conifers and \"false\" otherwise None leaf_on_start None a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round None leaf_off_start None a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). None leaf_transition_days None the number of days that the leaf on-off transition last. None Returns: Type Description None An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: | View Source def pai_seasons ( x , leaf_on_start , leaf_off_start , leaf_transition_days ) : \" \"\" The method updates Plant Area Index (PAI) with respect to leaf on-off seasons. Args: A data frame \" x \" with following variables: Date_time: (:obj:`time`): date and time BAI: Bark Area Index LAI: Leaf Area Index conifers: it taks value \" true \" if conifers and \" false \" otherwise leaf_on_start: a day in the year when the leaf on season starts. In the case of Glasgow it is April 14 (day 105). See also other sources: https://weatherspark.com/y/147740/Average-Weather-at-Glasgow-Airport-United-Kingdom-Year-Round leaf_off_start: a day in the year when the leaf off season starts. In the case of Glasgow it is November 2 (day 307). leaf_transition_days: the number of days that the leaf on-off transition last. Returns: An array of values of Plant Area Indexes (PAI) over time. Note: The function is built upon the following paper: Wang, Jun, Theodore A. Endreny, and David J. Nowak. \u201cMechanistic Simulation of Tree Effects in an Urban Water Balance Model 1.\u201d JAWRA Journal of the American Water Resources Association 44, no. 1 (February 2008): 75\u201385. https://doi.org/10.1111/j.1752-1688.2007.00139.x Todo: \"\" \" x = x . assign ( PAI = np . where ( x [ 'Conifers' ] , x [ 'BAI' ] + x [ 'LAI' ] , np . where ( x . Date_time . dt . day_of_year < leaf_on_start , x [ 'BAI' ] , np . where ((( x . Date_time . dt . day_of_year >= leaf_on_start ) & ( x . Date_time . dt . day_of_year < leaf_off_start )), x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * ( x . Date_time . dt . day_of_year - ( leaf_on_start + leaf_transition_days / 2 )))) + x [ 'BAI' ] , x [ 'LAI' ] / ( 1 + np . exp ( - 0.37 * (( leaf_off_start + leaf_transition_days / 2 ) - x . Date_time . dt . day_of_year ))) + x [ 'BAI' ] ))) ) return x [ 'PAI' ]","title":"pai_seasons"},{"location":"reference/src/impacts/water/#ped1","text":"def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ) The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args: Date_time [time identifier] Precipitation [amount of water hitting the surface area of the type] Potential_evaporation [of the type for the given weather conditions] Maximum_storage [parameter: maximum storage of the type] evp [evaporation coefficient for the type] Returns: Precipitation storage of the type for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def ped1 ( Date_time , Precipitation , Potential_evaporation , Maximum_storage , evp ) : \"\"\"The method computes precipitation-evaporation dynamics for one type at a time, which can be trees, pervious cover, impervious cover... Args : Date_time [ time identifier ] Precipitation [ amount of water hitting the surface area of the type ] Potential_evaporation [ of the type for the given weather conditions ] Maximum_storage [ parameter : maximum storage of the type ] evp [ evaporation coefficient for the type ] Returns : Precipitation storage of the type for each hour . Note : The function is built upon the following book : Maidment , David R and others . \u201c Handbook of Hydrology , McGraw - Hil . \u201d Inc ., New York , NY , 1992. And a paper : Hirabayashi , Satoshi . \u201c I - Tree Eco United States County - Based Hydrologic Estimates . \u201d Washington , DC : US Department of Agriculture , Forest Service , 2015. Todo : \"\"\" df = pd . DataFrame ({ ' Date_time ' : Date_time , ' Precipitation ' : Precipitation , ' Potential_evaporation ' : Potential_evaporation }) df [ \"Storage\" ] = 0 df [ ' Potential_evaporation_lag1 ' ] = df . Potential_evaporation . shift ( 1 ). interpolate ( limit_direction = ' backward ' ) x = 0 def func2 ( row ) : # non local variable ==> will use pre_value from the ped function nonlocal x new_value = new_value = np . maximum ( 0 ,( np . minimum ( Maximum_storage , x ) + row [ ' Precipitation ' ] - np . minimum ( np . minimum ( Maximum_storage , x ),(( np . minimum ( Maximum_storage , x ) / Maximum_storage ) ** ( evp ) * row [ ' Potential_evaporation_lag1 ' ])))) x = new_value return new_value # This line might throw a SettingWithCopyWarning warning df . loc [ 0 : , ' Storage ' ] = df . loc [ 0 : , : ]. apply ( func2 , axis = 1 ) return df [ \"Storage\" ]","title":"ped1"},{"location":"reference/src/impacts/water/#ped3","text":"def ped3 ( df , evp_v , evp_g ) The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Parameters: Name Type Description Default A data frame including the following variables None None Evaporation coefficient for trees None evp_v None Evaporation coefficient for ground None evp_g None Returns: Type Description None A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: | View Source def ped3 ( df , evp_v , evp_g ): \"\"\"The method computes precipitation-evaporation dynamics for each tree as well as the impervious and pervious covers. Args: A data frame including the following variables: Evaporation coefficient for trees: evp_v Evaporation coefficient for ground: evp_g Returns: A data frame with new variables: Vegetation_storage, Impervious_cover_storage_v, Pervious_cover_storage_v for each hour. Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" df [ 'Storage' ] = 0 df [ 'Potential_evaporation_v_lag1' ] = df . Potential_evaporation_v . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) df [ 'Potential_evaporation_g_lag1' ] = df . Potential_evaporation_g . shift ( 1 ) . interpolate ( limit_direction = 'backward' ) x = 0 y = 0 z = 0 def func2 ( row ): # non local variable ==> will use pre_value from the ped function nonlocal x nonlocal y nonlocal z new_value_x = np . maximum ( 0 ,( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) + row [ 'Canopy_interception' ] - np . minimum ( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ),(( np . minimum ( row [ 'Maximum_vegetation_storage' ], x ) / row [ 'Maximum_vegetation_storage' ]) ** ( evp_v ) * row [ 'Potential_evaporation_v_lag1' ])))) Precipitation_on_the_ground_with_vegetation = np . maximum ( 0 ,( new_value_x - row [ 'Maximum_vegetation_storage' ])) + row [ 'Through_canopy_precipitation' ] new_value_y = np . maximum ( 0 ,( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ),(( np . minimum ( MAXIMUM_IMPERVIOUS_COVER_STORAGE , y ) / MAXIMUM_IMPERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) new_value_z = np . maximum ( 0 ,( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) + Precipitation_on_the_ground_with_vegetation - np . minimum ( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ),(( np . minimum ( MAXIMUM_PERVIOUS_COVER_STORAGE , z ) / MAXIMUM_PERVIOUS_COVER_STORAGE ) ** ( evp_g ) * row [ 'Potential_evaporation_g_lag1' ])))) x = new_value_x y = new_value_y z = new_value_z return [ new_value_x , new_value_y , new_value_z ] # This line might throw a SettingWithCopyWarning warning df . loc [ 0 :, 'Storage' ] = df . loc [ 0 :,:] . apply ( func2 , axis = 1 ) df [ 'Vegetation_storage' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 0 ] df [ 'Impervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 1 ] df [ 'Pervious_cover_storage_v' ] = pd . DataFrame ( df [ 'Storage' ] . tolist ())[ 2 ] df = df . drop ( columns = 'Storage' ) return df","title":"ped3"},{"location":"reference/src/impacts/water/#potential_evaporation","text":"def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ) The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: View Source def potential_evaporation ( temperature , dew_point , solar_radiation , sea_level_pressure , pai , wind_speed , wind_estimate_height , roughness_height ) : \"\" \"The method calculate potential evaporation. Args: a data frame Returns: the updated ata frame Note: Todo: \"\" \" potential_evaporation = M_TO_MM*(1/(lmbd(temperature)*rho_w(temperature)))*(DELTA(temperature)*solar_radiation+(rho_a(temperature, sea_level_pressure)*c_p*D(temperature, dew_point))/r_a(wind_speed, wind_estimate_height, roughness_height))/(DELTA(temperature)+gamma(temperature, sea_level_pressure)*(1+(r_s(pai)/r_a(wind_speed, wind_estimate_height, roughness_height)))) return potential_evaporation","title":"potential_evaporation"},{"location":"reference/src/impacts/water/#potential_evapotranspiration","text":"def potential_evapotranspiration ( df ) The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: View Source def potential_evapotranspiration ( df ) : \"\"\"The method calculate potential evapotranspiration. Args: a data frame Returns: the updated ata frame Note: Todo: \"\"\" df = df . assign ( Potential_evaporation_v = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , roughness_height_trees ), Potential_evaporation_g = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , 1 , x . Wind_Speed , 1 , roughness_height_bare_soil ), PET = lambda x: potential_evaporation ( x . Temperature , x . Dew_Point , x . Solar_Radiation , x . Sea_Level_Pressure , x . PAI , x . Wind_Speed , x . height , - 1 ), Transpiration = lambda x: 10 ** ( - 6 ) * ( 3600 / x . PAI ) * np . maximum (( C_leaf ( x . Temperature ) - C_air ( x . Dew_Point , x . Temperature )), 0 ) / ( r_s ( x . PAI ) + r_a ( x . Wind_Speed , x . height , roughness_height_trees )) ) df = df . assign ( TF_average_ratio = lambda x: np . where ((( x . PET > x . Transpiration ) & ( x . PET > 0 )), x . Transpiration / x . PET , np . nan ) ) df [' TF_average_ratio '] = df . groupby ([' AgentID ',' Step '])[' TF_average_ratio ']. transform (' mean ') df = df . assign ( Transpiration = lambda x: np . where ((( x . PAI < ( x . LAI + x . BAI )) | ( x . Transpiration > x . PET )), x . TF_average_ratio * x . PET , x . Transpiration ) ) df = df . drop ( columns = ' TF_average_ratio ') return df","title":"potential_evapotranspiration"},{"location":"reference/src/impacts/water/#r_a","text":"def r_a ( wind_speed , wind_estimate_height , roughness_height ) The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def r_a ( wind_speed , wind_estimate_height , roughness_height ) : \"\"\"The method calculates aerodynamic resistance. Args: Measured wind speed [m/s] Wind estimate height (tree height) [m] Roughness_height [m] Returns: Aerodynamic resistance in [m/s] Note: It includes in calculation wind speed at the tree top U_t. If roughness height is negative, a new equation is applied to calculate aerodynamic resistance for the evapotranspiration from the soil. The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" if roughness_height >= 0 : return 4.72 * np . log ( wind_estimate_height / ( Z_ov * roughness_height )) / ( 1 + 0.53 * U_t ( wind_speed , wind_estimate_height )) else : return 208 / U_t ( wind_speed , wind_estimate_height )","title":"r_a"},{"location":"reference/src/impacts/water/#r_s","text":"def r_s ( pai ) The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def r_s ( pai ) : \"\" \"The method calculates stomatal resistance. Args: Plant area index (PAI) Returns: Stomatal resistance in [s/m] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\" \" return 200/pai","title":"r_s"},{"location":"reference/src/impacts/water/#rho_a","text":"def rho_a ( temperature , surface_pressure ) The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def rho_a ( temperature , surface_pressure ) : \"\"\"The method calculates the density of air. Args: Temperature in [C] Surface preasure in [kPa] Returns: The density of air in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 3.486 * surface_pressure / ( 275 + temperature )","title":"rho_a"},{"location":"reference/src/impacts/water/#rho_w","text":"def rho_w ( temperature ) The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: View Source def rho_w ( temperature ) : \"\"\"The method calculates the density of water. Args: Temperature in [C] Returns: The density of water in [kg/m^3] Note: The function is built upon the following book: Maidment, David R and others. \u201cHandbook of Hydrology, McGraw-Hil.\u201d Inc., New York, NY, 1992. And a paper: Hirabayashi, Satoshi. \u201cI-Tree Eco United States County-Based Hydrologic Estimates.\u201d Washington, DC: US Department of Agriculture, Forest Service, 2015. Todo: \"\"\" return 999.88 + 0.018 * temperature - 0.0051 * temperature ** 2","title":"rho_w"},{"location":"reference/src/impacts/water/#classes","text":"","title":"Classes"},{"location":"reference/src/impacts/water/#calibration","text":"class Calibration ( leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.001 , impervios_storage_max = 0.0015 ) View Source class Calibration () : \" \"\" Water retention and impact estimate related parameters setting. \"\" \" # Conversion coefficient meter to millimeter m_to_mm = 1 # Extinction coefficient =0.7 for trees and 0.3 for shrubs (Wang et al. 2008) kappa = 0.7 # Shade factor, is the percentage of sky covered by foliage and branches within # the perimeter of individual tree crowns, can vary by species from about # 60% to 95% when trees are in-leaf (McPherson, 1984). # The value below is set according to Glasgow mean avg_shade_factor = 0.85 # Specific leaf storage of water (sl =0.0002 m). leaf_storage = 0.0002 * m_to_mm # Leaf-on leaf_off transition days (Wang_et_al_2008). leaf_transition_days = 28 # Specific impervious cover storage of water (=0.0015 m). maximum_impervious_cover_storage = 0.0015 * m_to_mm # Specific pervious cover storage of water (=0.001 m). maximum_pervious_cover_storage = 0.001 * m_to_mm def __init__ ( self , leaf_transition_days = 28 , leaf_storage = 0.0002 , pervios_storage_max = 0.0010 , impervios_storage_max = 0.0015 ) : \" \"\" The constructor method. Args: leaf_transition_days: (:obj:`int`): Leaf-on leaf_off transition days leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: TODO: * pass optional settings as key word parameters. \"\" \" self . leaf_storage = leaf_storage * Calibration . m_to_mm self . leaf_transition_days = leaf_transition_days self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm def set _surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) : \" \"\" Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\" \" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm","title":"Calibration"},{"location":"reference/src/impacts/water/#class-variables","text":"avg_shade_factor kappa leaf_storage leaf_transition_days m_to_mm maximum_impervious_cover_storage maximum_pervious_cover_storage","title":"Class variables"},{"location":"reference/src/impacts/water/#methods","text":"","title":"Methods"},{"location":"reference/src/impacts/water/#set_surface_storage_rates","text":"def set_surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) Setting specific water storage rates. Parameters: Name Type Description Default leaf_storage None (:obj: float ): Specific leaf storage of water. None pervios_storage_max None (:obj: float ): Specific pervious cover storage of water None impervios_storage_max None (:obj: float ): Specific impervious cover storage of water None Returns: Type Description None None Note: Todo: | View Source def set _surface_storage_rates ( self , leaf_storage = None , pervios_storage_max = None , impervios_storage_max = None ) : \" \"\" Setting specific water storage rates. Args: leaf_storage: (:obj:`float`): Specific leaf storage of water. pervios_storage_max: (:obj:`float`): Specific pervious cover storage of water impervios_storage_max: (:obj:`float`): Specific impervious cover storage of water Returns: None Note: Todo: \"\" \" if leaf_storage : self . leaf_storage = leaf_storage * Calibration . m_to_mm if impervios_storage_max : self . maximum_impervious_cover_storage = impervios_storage_max * Calibration . m_to_mm if pervios_storage_max : self . maximum_pervious_cover_storage = pervios_storage_max * Calibration . m_to_mm","title":"set_surface_storage_rates"}]}